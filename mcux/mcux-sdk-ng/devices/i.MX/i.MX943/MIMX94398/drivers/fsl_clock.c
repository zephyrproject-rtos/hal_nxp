/*
 * Copyright 2024 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
#include "fsl_clock.h"
#ifdef CONFIG_DIRECT
#include "fsl_fract_pll.h"
#include "fsl_fro.h"
#include "fsl_ccm.h"
#include "fsl_power.h"
#include "fsl_src.h"
#endif

/*******************************************************************************
 * Definitions
 ******************************************************************************/
/* Component ID definition, used by tools. */
#ifndef FSL_COMPONENT_ID
#define FSL_COMPONENT_ID "platform.drivers.clock"
#endif

volatile uint64_t g_clockSourceFreq[CLOCK_NUM_SRC];

uint64_t g_clockExt1Rate = 0UL;

const pll_attr_t g_pllAttrs[CLOCK_NUM_PLL] =
{
    [CLOCK_PLL_SYS1].isFrac = true,
    [CLOCK_PLL_SYS1].numDFS = 3U,

    [CLOCK_PLL_AUDIO1].isFrac = true,
    [CLOCK_PLL_AUDIO1].numDFS = 0U,

    [CLOCK_PLL_AUDIO2].isFrac = true,
    [CLOCK_PLL_AUDIO2].numDFS = 0U,

    [CLOCK_PLL_ENCODER].isFrac = false,
    [CLOCK_PLL_ENCODER].numDFS = 2U,

    [CLOCK_PLL_ARM].isFrac = false,
    [CLOCK_PLL_ARM].numDFS = 4U,

    [CLOCK_PLL_DRAM].isFrac = true,
    [CLOCK_PLL_DRAM].numDFS = 0U,

    [CLOCK_PLL_HSIO].isFrac = true,
    [CLOCK_PLL_HSIO].numDFS = 0U,

    [CLOCK_PLL_LDB].isFrac = true,
    [CLOCK_PLL_LDB].numDFS = 0U,
};

/* TODO below array need to be updated when clock tree info is ready */
const uint8_t g_clockRootMux[CLOCK_NUM_ROOT][CLOCK_NUM_ROOT_MUX_SEL] =
{
    [CLOCK_ROOT_ADC][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ADC][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ADC][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ADC][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_BUSAON][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_BUSAON][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_BUSAON][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_BUSAON][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_CAN1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CAN1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_CAN1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_CAN1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_GLITCHFILTER][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_GLITCHFILTER][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_GLITCHFILTER][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_GLITCHFILTER][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_GPT1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_GPT1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_GPT1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_GPT1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_I3C1SLOW][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_I3C1SLOW][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_I3C1SLOW][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_I3C1SLOW][3] = CLOCK_SRC_OSC24M,

    [CLOCK_ROOT_LPI2C1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPTMR1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPTMR1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPTMR1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPTMR1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART1][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART2][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_M33][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M33][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_M33][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_M33][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_M33SYSTICK][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M33SYSTICK][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_M33SYSTICK][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_M33SYSTICK][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_PDM][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_PDM][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_PDM][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_PDM][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_SAI1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_SAI1][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_SAI1][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_SAI1][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_TPM2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_TPM2][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_TPM2][2] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_TPM2][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_A55][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_A55][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_A55][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_A55][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_A55MTRBUS][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_A55MTRBUS][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_A55MTRBUS][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_A55MTRBUS][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_A55PERIPH][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_A55PERIPH][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_A55PERIPH][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_A55PERIPH][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_DRAMALT][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_DRAMALT][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_DRAMALT][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_DRAMALT][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_DRAMAPB][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_DRAMAPB][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_DRAMAPB][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_DRAMAPB][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_DISPAPB][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_DISPAPB][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_DISPAPB][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_DISPAPB][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_DISPAXI][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_DISPAXI][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_DISPAXI][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_DISPAXI][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_DISPPIX][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_DISPPIX][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_DISPPIX][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_DISPPIX][3] = CLOCK_SRC_SYSPLL1_PFD0,

    [CLOCK_ROOT_HSIOACSCAN480M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOACSCAN480M][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_HSIOACSCAN480M][2] = CLOCK_SRC_ENCPLL_PFD1,
    [CLOCK_ROOT_HSIOACSCAN480M][3] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,

    [CLOCK_ROOT_HSIOACSCAN80M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOACSCAN80M][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_HSIOACSCAN80M][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HSIOACSCAN80M][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_HSIO][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIO][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_HSIO][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_HSIO][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_HSIOPCIEAUX][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOPCIEAUX][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_HSIOPCIEAUX][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HSIOPCIEAUX][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_HSIOPCIETEST160M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOPCIETEST160M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_HSIOPCIETEST160M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_HSIOPCIETEST160M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_HSIOPCIETEST400M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOPCIETEST400M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_HSIOPCIETEST400M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_HSIOPCIETEST400M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_HSIOPCIETEST500M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOPCIETEST500M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_HSIOPCIETEST500M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_HSIOPCIETEST500M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_HSIOPCIETEST50M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOPCIETEST50M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_HSIOPCIETEST50M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_HSIOPCIETEST50M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_HSIOUSBTEST60M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HSIOUSBTEST60M][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_HSIOUSBTEST60M][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HSIOUSBTEST60M][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_BUSM70][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_BUSM70][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_BUSM70][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_BUSM70][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_M70][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M70][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_M70][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_M70][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_M70SYSTICK][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M70SYSTICK][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_M70SYSTICK][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_M70SYSTICK][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_BUSM71][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_BUSM71][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_BUSM71][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_BUSM71][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_M71][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M71][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_M71][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_M71][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_M71SYSTICK][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M71SYSTICK][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_M71SYSTICK][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_M71SYSTICK][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_BUSNETCMIX][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_BUSNETCMIX][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_BUSNETCMIX][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_BUSNETCMIX][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ECAT][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ECAT][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ECAT][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ECAT][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENET][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENET][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_ENET][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_ENET][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_ENETPHYTEST200M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETPHYTEST200M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_ENETPHYTEST200M][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENETPHYTEST200M][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENETPHYTEST500M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETPHYTEST500M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_ENETPHYTEST500M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_ENETPHYTEST500M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_ENETPHYTEST667M][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETPHYTEST667M][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_ENETPHYTEST667M][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_ENETPHYTEST667M][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_ENETREF][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETREF][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_ENETREF][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENETREF][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENETTIMER1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETTIMER1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENETTIMER1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENETTIMER1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENETTIMER2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETTIMER2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENETTIMER2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENETTIMER2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENETTIMER3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENETTIMER3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENETTIMER3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENETTIMER3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_FLEXIO3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_FLEXIO3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_FLEXIO3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_FLEXIO3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_FLEXIO4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_FLEXIO4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_FLEXIO4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_FLEXIO4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_M33SYNC][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M33SYNC][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_M33SYNC][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_M33SYNC][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_M33SYNCSYSTICK][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_M33SYNCSYSTICK][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_M33SYNCSYSTICK][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_M33SYNCSYSTICK][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC0][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC0][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC0][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC0][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC1][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC2][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC3][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC4][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_MAC5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_MAC5][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_MAC5][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_MAC5][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_NOCAPB][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_NOCAPB][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_NOCAPB][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_NOCAPB][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_NOC][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_NOC][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_NOC][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_NOC][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_NPUAPB][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_NPUAPB][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_NPUAPB][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_NPUAPB][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_NPU][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_NPU][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_NPU][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_NPU][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_CCMCKO1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CCMCKO1][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_CCMCKO1][2] = CLOCK_SRC_OSC32K,
    [CLOCK_ROOT_CCMCKO1][3] = CLOCK_SRC_AUDIOPLL1,

    [CLOCK_ROOT_CCMCKO2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CCMCKO2][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_CCMCKO2][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_CCMCKO2][3] = CLOCK_SRC_AUDIOPLL2,

    [CLOCK_ROOT_CCMCKO3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CCMCKO3][1] = CLOCK_SRC_OSC32K,
    [CLOCK_ROOT_CCMCKO3][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_CCMCKO3][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_CCMCKO4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CCMCKO4][1] = CLOCK_SRC_ENCPLL_PFD1,
    [CLOCK_ROOT_CCMCKO4][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_CCMCKO4][3] = CLOCK_SRC_AUDIOPLL2,

    [CLOCK_ROOT_BISS][0] = CLOCK_SRC_OSC24M, 
    [CLOCK_ROOT_BISS][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2, 
    [CLOCK_ROOT_BISS][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2, 
    [CLOCK_ROOT_BISS][3] = CLOCK_SRC_FRO, 

    [CLOCK_ROOT_BUSWAKEUP][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_BUSWAKEUP][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_BUSWAKEUP][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_BUSWAKEUP][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_CAN2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CAN2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_CAN2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_CAN2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_CAN3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CAN3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_CAN3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_CAN3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_CAN4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CAN4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_CAN4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_CAN4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_CAN5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_CAN5][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_CAN5][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_CAN5][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENDAT21][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENDAT21][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENDAT21][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENDAT21][3] = CLOCK_SRC_ENCPLL_PFD1,

    [CLOCK_ROOT_ENDAT22][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENDAT22][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENDAT22][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENDAT22][3] = CLOCK_SRC_ENCPLL_PFD1,

    [CLOCK_ROOT_ENDAT31FAST][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENDAT31FAST][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENDAT31FAST][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENDAT31FAST][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_ENDAT31SLOW][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_ENDAT31SLOW][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_ENDAT31SLOW][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_ENDAT31SLOW][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_FLEXIO1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_FLEXIO1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_FLEXIO1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_FLEXIO1][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_FLEXIO2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_FLEXIO2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_FLEXIO2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_FLEXIO2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_GPT2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_GPT2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_GPT2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_GPT2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_GPT3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_GPT3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_GPT3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_GPT3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_GPT4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_GPT4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_GPT4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_GPT4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_HIPERFACE1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HIPERFACE1][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_HIPERFACE1][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HIPERFACE1][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_HIPERFACE1SYNC][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HIPERFACE1SYNC][1] = CLOCK_SRC_OSC32K,
    [CLOCK_ROOT_HIPERFACE1SYNC][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HIPERFACE1SYNC][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_HIPERFACE2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HIPERFACE2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_HIPERFACE2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HIPERFACE2][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_HIPERFACE2SYNC][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_HIPERFACE2SYNC][1] = CLOCK_SRC_OSC32K,
    [CLOCK_ROOT_HIPERFACE2SYNC][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_HIPERFACE2SYNC][3] = CLOCK_SRC_ENCPLL_PFD0,

    [CLOCK_ROOT_I3C2SLOW][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_I3C2SLOW][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_I3C2SLOW][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_I3C2SLOW][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C5][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C5][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C5][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C6][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C6][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C6][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C6][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C7][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C7][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C7][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C7][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPI2C8][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPI2C8][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPI2C8][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPI2C8][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI3][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI4][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI5][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI5][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI5][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI6][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI6][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI6][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI6][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI7][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI7][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI7][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI7][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPSPI8][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPSPI8][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPSPI8][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPSPI8][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPTMR2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPTMR2][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPTMR2][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_LPTMR2][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART10][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART10][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART10][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART10][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART11][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART11][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART11][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART11][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART12][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART12][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART12][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART12][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART3][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART3][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART3][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART4][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART4][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART4][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART5][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART5][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART5][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART6][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART6][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART6][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART6][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART7][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART7][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART7][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART7][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART8][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART8][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART8][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART8][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_LPUART9][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_LPUART9][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_LPUART9][2] = CLOCK_SRC_ENCPLL_PFD0,
    [CLOCK_ROOT_LPUART9][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_SAI2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_SAI2][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_SAI2][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_SAI2][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_SAI3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_SAI3][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_SAI3][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_SAI3][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_SAI4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_SAI4][1] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_SAI4][2] = CLOCK_SRC_AUDIOPLL2,
    [CLOCK_ROOT_SAI4][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_SWOTRACE][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_SWOTRACE][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_SWOTRACE][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_SWOTRACE][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_TPM4][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_TPM4][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_TPM4][2] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_TPM4][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_TPM5][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_TPM5][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_TPM5][2] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_TPM5][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_TPM6][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_TPM6][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_TPM6][2] = CLOCK_SRC_AUDIOPLL1,
    [CLOCK_ROOT_TPM6][3] = CLOCK_SRC_EXT,

    [CLOCK_ROOT_USBPHYBURUNIN][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_USBPHYBURUNIN][1] = CLOCK_SRC_SYSPLL1_PFD0_DIV2,
    [CLOCK_ROOT_USBPHYBURUNIN][2] = CLOCK_SRC_SYSPLL1_PFD1_DIV2,
    [CLOCK_ROOT_USBPHYBURUNIN][3] = CLOCK_SRC_FRO,

    [CLOCK_ROOT_USDHC1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_USDHC1][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_USDHC1][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_USDHC1][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_USDHC2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_USDHC2][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_USDHC2][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_USDHC2][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_USDHC3][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_USDHC3][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_USDHC3][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_USDHC3][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_V2XPK][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_V2XPK][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_V2XPK][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_V2XPK][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_WAKEUPAXI][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_WAKEUPAXI][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_WAKEUPAXI][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_WAKEUPAXI][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_XSPISLVROOT][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_XSPISLVROOT][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_XSPISLVROOT][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_XSPISLVROOT][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_XSPI1][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_XSPI1][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_XSPI1][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_XSPI1][3] = CLOCK_SRC_SYSPLL1_PFD2,

    [CLOCK_ROOT_XSPI2][0] = CLOCK_SRC_OSC24M,
    [CLOCK_ROOT_XSPI2][1] = CLOCK_SRC_SYSPLL1_PFD0,
    [CLOCK_ROOT_XSPI2][2] = CLOCK_SRC_SYSPLL1_PFD1,
    [CLOCK_ROOT_XSPI2][3] = CLOCK_SRC_SYSPLL1_PFD2,
};

/* CCM GPR-selected clocks may be sources/roots.  Encode selections
 * that map to roots as offset ]from CLOCK_NUM_SRC for unique mapping.
 */
const ccm_gpr_sel_attr_t g_clockGprSel[CLOCK_NUM_GPR_SEL] =
{
    [CLOCK_GPR_SEL_EXT]
    {
        .selIdx = 0U,
        .selMask = 0x1U,
        .selShift = 0U,
        .selMux[0] = CLOCK_SRC_EXT1,
        .selMux[1] = CLOCK_SRC_EXT2,
    },
    /* EXT2/EXT3/EXT4 all tied to GND */

    [CLOCK_GPR_SEL_A55C0]
    {
        .selIdx = 1U,
        .selMask = CCM_GPR_SHARED1_CA55_CORE0_CLOCK_SELECT_MASK,
        .selShift = CCM_GPR_SHARED1_CA55_CORE0_CLOCK_SELECT_SHIFT,
        .selMux[0] = CLOCK_NUM_SRC + CLOCK_ROOT_A55,
        .selMux[1] = CLOCK_SRC_ARMPLL_PFD0,
    },

    [CLOCK_GPR_SEL_A55C1]
    {
        .selIdx = 1U,
        .selMask = CCM_GPR_SHARED1_CA55_CORE1_CLOCK_SELECT_MASK,
        .selShift = CCM_GPR_SHARED1_CA55_CORE1_CLOCK_SELECT_SHIFT,
        .selMux[0] = CLOCK_NUM_SRC + CLOCK_ROOT_A55,
        .selMux[1] = CLOCK_SRC_ARMPLL_PFD0,
    },

    [CLOCK_GPR_SEL_A55C2]
    {
        .selIdx = 1U,
        .selMask = CCM_GPR_SHARED1_CA55_CORE2_CLOCK_SELECT_MASK,
        .selShift = CCM_GPR_SHARED1_CA55_CORE2_CLOCK_SELECT_SHIFT,
        .selMux[0] = CLOCK_NUM_SRC + CLOCK_ROOT_A55,
        .selMux[1] = CLOCK_SRC_ARMPLL_PFD1,
    },

    [CLOCK_GPR_SEL_A55C3]
    {
        .selIdx = 1U,
        .selMask = CCM_GPR_SHARED1_CA55_CORE3_CLOCK_SELECT_MASK,
        .selShift = CCM_GPR_SHARED1_CA55_CORE3_CLOCK_SELECT_SHIFT,
        .selMux[0] = CLOCK_NUM_SRC + CLOCK_ROOT_A55,
        .selMux[1] = CLOCK_SRC_ARMPLL_PFD1,
    },

    [CLOCK_GPR_SEL_A55P]
    {
        .selIdx = 1U,
        .selMask = CCM_GPR_SHARED1_CA55_PLATFORM_CLOCK_SELECT_MASK,
        .selShift = CCM_GPR_SHARED1_CA55_PLATFORM_CLOCK_SELECT_SHIFT,
        .selMux[0] = CLOCK_NUM_SRC + CLOCK_ROOT_A55,
        .selMux[1] = CLOCK_SRC_ARMPLL_PFD3,
    },

    [CLOCK_GPR_SEL_DRAM]
    {
        .selIdx = 2U,
        .selMask = CCM_GPR_SHARED2_DRAM_PLL_BYPASS_MASK,
        .selShift = CCM_GPR_SHARED2_DRAM_PLL_BYPASS_SHIFT,
        .selMux[0] = CLOCK_SRC_DRAMPLL,
        .selMux[1] = CLOCK_NUM_SRC + CLOCK_ROOT_DRAMALT,
    },

    [CLOCK_GPR_SEL_TEMPSENSE]
    {
        .selIdx = 2U,
        .selMask = CCM_GPR_SHARED2_ANAMIX_TEMPSENSE_CLK_SEL_MASK,
        .selShift = CCM_GPR_SHARED2_ANAMIX_TEMPSENSE_CLK_SEL_SHIFT,
        .selMux[0] = CLOCK_SRC_OSC24M,
        .selMux[1] = CLOCK_SRC_FRO,
    }
};

/* CCM CGC attributes */
const ccm_cgc_attr_t g_clockCgcAttr[CLOCK_NUM_CGC] =
{
    [CLOCK_CGC_NPU]
    {
        .lpcgIdx = 2U,
        .rootIdx = CLOCK_ROOT_NPU,
    }
};

#ifdef CONFIG_DIRECT
uint64_t CLOCK_GetSourceFreq(uint32_t sourceIdx);

uint64_t CLOCK_GetIpFreq(clock_root_t name)
{
    clock_name_t clock;
    uint32_t mux;
    uint32_t div;

    mux = CLOCK_GetRootClockMux(name);
    div = CLOCK_GetRootClockDiv(name);

    clock = CLOCK_GetRootClockSource(name, mux);
    assert(clock <= kCLOCK_LdbPll);
    g_clockSourceFreq[clock] = CLOCK_GetSourceFreq((uint32_t)clock);

    return g_clockSourceFreq[clock] / div;
}

/*--------------------------------------------------------------------------*/
/* Check if CCM clock source power domain enabled                           */
/*--------------------------------------------------------------------------*/
static bool CLOCK_SourcePdIsOn(uint32_t sourceIdx)
{
    bool pdOn = true;

    switch(sourceIdx)
    {
        case CLOCK_SRC_ARMPLL_VCO:
        case CLOCK_SRC_ARMPLL_PFD0:
        case CLOCK_SRC_ARMPLL_PFD0_UNGATED:
        case CLOCK_SRC_ARMPLL_PFD1:
        case CLOCK_SRC_ARMPLL_PFD1_UNGATED:
        case CLOCK_SRC_ARMPLL_PFD2:
        case CLOCK_SRC_ARMPLL_PFD2_UNGATED:
        case CLOCK_SRC_ARMPLL_PFD3:
        case CLOCK_SRC_ARMPLL_PFD3_UNGATED:
            pdOn = SRC_MixIsPwrReady(PWR_MIX_SLICE_IDX_A55P);
            break;

        case CLOCK_SRC_DRAMPLL_VCO:
        case CLOCK_SRC_DRAMPLL:
            pdOn = SRC_MixIsPwrReady(PWR_MIX_SLICE_IDX_DDR);
            break;

        case CLOCK_SRC_HSIOPLL_VCO:
        case CLOCK_SRC_HSIOPLL:
              /* TODO */
            pdOn = SRC_MixIsPwrReady(PWR_MIX_SLICE_IDX_HSIO_TOP);
            break;

        case CLOCK_SRC_LDBPLL_VCO:
        case CLOCK_SRC_LDBPLL:
              /* TODO */
            pdOn = SRC_MixIsPwrReady(PWR_MIX_SLICE_IDX_DISPLAY);
            break;

        default:
            ; /* Intentional empty default */
            break;
    }

    return pdOn;
}



/*--------------------------------------------------------------------------
 * Get CCM clock source frequency
 *--------------------------------------------------------------------------*/
uint64_t CLOCK_GetSourceFreq(uint32_t sourceIdx)
{
    uint64_t rate = 0UL;

    if (CLOCK_SourcePdIsOn(sourceIdx))
    {        
        switch(sourceIdx)
        {
            case CLOCK_SRC_EXT:
                /* Refrain from calling CLOCK_GprSelGetRate to avoid
                   possible recursion */
                rate = CCM_GprSelExtGetRate();
                break;

            case CLOCK_SRC_OSC32K:
                rate = CLOCK_OSC32K_HZ;
                break;

            case CLOCK_SRC_OSC24M:
                rate = CLOCK_OSC24M_HZ;
                break;

            case CLOCK_SRC_FRO:
                {
                    uint32_t froRate;
                    
                    if (FRO_GetRate(&froRate))
                    {
                        rate = ((uint64_t) froRate) * CLOCK_M_HZ;
                    }
                    else
                    {
                        rate = CLOCK_FRO_HZ;
                    }
                }
                break;

            case CLOCK_SRC_SYSPLL1_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_SYS1, true);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_UNGATED:
            case CLOCK_SRC_SYSPLL1_PFD0:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 0U, false);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_DIV2:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 0U, true);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_UNGATED:
            case CLOCK_SRC_SYSPLL1_PFD1:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 1U, false);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_DIV2:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 1U, true);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_UNGATED:
            case CLOCK_SRC_SYSPLL1_PFD2:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 2U, false);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_DIV2:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_SYS1, 2U, true);
                break;

            case CLOCK_SRC_AUDIOPLL1_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_AUDIO1, true);
                break;

            case CLOCK_SRC_AUDIOPLL1:
                rate = FRACTPLL_GetRate(CLOCK_PLL_AUDIO1, false);
                break;

            case CLOCK_SRC_AUDIOPLL2_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_AUDIO2, true);
                break;

            case CLOCK_SRC_AUDIOPLL2:
                rate = FRACTPLL_GetRate(CLOCK_PLL_AUDIO2, false);
                break;

            case CLOCK_SRC_ENCPLL_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_ENCODER, true);
                break;

            case CLOCK_SRC_ENCPLL_PFD0_UNGATED:
            case CLOCK_SRC_ENCPLL_PFD0:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ENCODER, 0, false);
                break;

            case CLOCK_SRC_ENCPLL_PFD1_UNGATED:
            case CLOCK_SRC_ENCPLL_PFD1:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ENCODER, 1, false);
                break;

            case CLOCK_SRC_ARMPLL_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_ARM, true);
                break;

            case CLOCK_SRC_ARMPLL_PFD0_UNGATED:
            case CLOCK_SRC_ARMPLL_PFD0:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ARM, 0U, false);
                break;

            case CLOCK_SRC_ARMPLL_PFD1_UNGATED:
            case CLOCK_SRC_ARMPLL_PFD1:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ARM, 1U, false);
                break;

            case CLOCK_SRC_ARMPLL_PFD2_UNGATED:
            case CLOCK_SRC_ARMPLL_PFD2:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ARM, 2U, false);
                break;

            case CLOCK_SRC_ARMPLL_PFD3_UNGATED:
            case CLOCK_SRC_ARMPLL_PFD3:
                rate = FRACTPLL_GetDfsRate(CLOCK_PLL_ARM, 3U, false);
                break;

            case CLOCK_SRC_DRAMPLL_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_DRAM, true);
                break;

            case CLOCK_SRC_DRAMPLL:
                rate = FRACTPLL_GetRate(CLOCK_PLL_DRAM, false);
                break;

            case CLOCK_SRC_HSIOPLL_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_HSIO, true);
                break;

            case CLOCK_SRC_HSIOPLL:
                rate = FRACTPLL_GetRate(CLOCK_PLL_HSIO, false);
                break;

            case CLOCK_SRC_LDBPLL_VCO:
                rate = FRACTPLL_GetRate(CLOCK_PLL_LDB, true);
                break;

            case CLOCK_SRC_LDBPLL:
                rate = FRACTPLL_GetRate(CLOCK_PLL_LDB, false);
                break;

            case CLOCK_SRC_EXT1:
                /* EXT1 is board-specific.  Return rate stored on
                 * previous set rate call for this source.
                 */
                rate = g_clockExt1Rate;
                break;

                /* EXT2 internally tied to GND, no case needed */

            default:
                ; /* Intentional empty default */
                break;
        }
    }

    return rate;
}

/*--------------------------------------------------------------------------
 * Set CCM clock source frequency
 *--------------------------------------------------------------------------*/
bool CLOCK_SourceSetRate(uint32_t sourceIdx, uint64_t rate,
    uint32_t roundRule)
{
    bool updateRate = false;

    /* Clock sources in MIXes not always-on require power dependency check. */
    if (CLOCK_SourcePdIsOn(sourceIdx))
    {
        switch(sourceIdx)
        {
            case CLOCK_SRC_SYSPLL1_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_SYS1, true, rate);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_SYS1, 0U, rate);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_SYS1, 1U, rate);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_SYS1, 2U, rate);
                break;

            case CLOCK_SRC_AUDIOPLL1_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_AUDIO1, true, rate);
                break;

            case CLOCK_SRC_AUDIOPLL1:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_AUDIO1, false, rate);
                break;

            case CLOCK_SRC_AUDIOPLL2_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_AUDIO2, true, rate);
                break;

            case CLOCK_SRC_AUDIOPLL2:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_AUDIO2, false, rate);
                break;

            case CLOCK_SRC_ENCPLL_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_ENCODER, true, rate);
                break;

            case CLOCK_SRC_ENCPLL_PFD0_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ENCODER, 0U, rate);
                break;

            case CLOCK_SRC_ENCPLL_PFD1_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ENCODER, 1U, rate);
                break;

            case CLOCK_SRC_ARMPLL_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_ARM, true, rate);
                break;

            case CLOCK_SRC_ARMPLL_PFD0_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ARM, 0U, rate);
                break;

            case CLOCK_SRC_ARMPLL_PFD1_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ARM, 1U, rate);
                break;

            case CLOCK_SRC_ARMPLL_PFD2_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ARM, 2U, rate);
                break;

            case CLOCK_SRC_ARMPLL_PFD3_UNGATED:
                updateRate = FRACTPLL_SetDfsRate(CLOCK_PLL_ARM, 3U, rate);
                break;

            case CLOCK_SRC_DRAMPLL_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_DRAM, true, rate);
                break;

            case CLOCK_SRC_DRAMPLL:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_DRAM, false, rate);
                break;

            case CLOCK_SRC_HSIOPLL_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_HSIO, true, rate);
                break;

            case CLOCK_SRC_HSIOPLL:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_HSIO, false, rate);
                break;

            case CLOCK_SRC_LDBPLL_VCO:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_LDB, true, rate);
                break;

            case CLOCK_SRC_LDBPLL:
                updateRate = FRACTPLL_SetRate(CLOCK_PLL_LDB, false, rate);
                break;

            case CLOCK_SRC_EXT1:
                /* EXT1 is board-specific.  Store the rate to be
                 * used on subsequent get rate calls for this source.
                 */
                g_clockExt1Rate = rate;
                updateRate = true;
                break;

            default:
                ; /* Intentional empty default */
                break;
        }
    }

    if (updateRate)
    {
        /* Overclocking of clock sources is not supported.  Floor rounding
         * rule can be met when hardare supports exact requested rate.  Closest
         * rounding rule handled same as ceiling rounding rule.
         */
        if (roundRule == CLOCK_ROUND_RULE_FLOOR)
        {
            uint64_t actualRate = CLOCK_SourceGetRate(sourceIdx);
            if (actualRate < rate)
            {
                updateRate = false;
            }
        }
    }

    return updateRate;
}

/*
 * Compatible with ccm driver
 */
uint64_t CLOCK_SourceGetRate(uint32_t sourceIdx)
{
	return CLOCK_GetSourceFreq(sourceIdx);
}

/*--------------------------------------------------------------------------*/
/* Get CCM clock source enable status                                       */
/*--------------------------------------------------------------------------*/
bool CLOCK_SourceGetEnable(uint32_t sourceIdx)
{
    bool clkEnable = false;
    
    if (CLOCK_SourcePdIsOn(sourceIdx))
    {
        switch(sourceIdx)
        {
            case CLOCK_SRC_EXT:
                clkEnable = true;
                break;

            case CLOCK_SRC_OSC32K:
                clkEnable = true;
                break;

            case CLOCK_SRC_OSC24M:
                clkEnable = true;
                break;

            case CLOCK_SRC_FRO:
                clkEnable = true;
                break;

            case CLOCK_SRC_SYSPLL1_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_SYS1,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_DIV2:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 1U,
                    PLL_DFS_ENABLE_MASK);
                break;
            
            case CLOCK_SRC_SYSPLL1_PFD1:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 1U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_DIV2:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 1,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;
            
            case CLOCK_SRC_SYSPLL1_PFD2_DIV2:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK);
                break;

            case CLOCK_SRC_AUDIOPLL1_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_AUDIO1,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_AUDIOPLL1:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_AUDIO1,
                    PLL_CTRL_CLKMUX_EN_MASK);
                break;

            case CLOCK_SRC_AUDIOPLL2_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_AUDIO2,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_AUDIOPLL2:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_AUDIO2,
                    PLL_CTRL_CLKMUX_EN_MASK);
                break;

            case CLOCK_SRC_ENCPLL_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_ENCODER,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_ENCPLL_PFD0_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ENCODER,
                    0, PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ENCPLL_PFD0:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ENCODER,
                    0, PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_ENCPLL_PFD1_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ENCODER,
                    1, PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ENCPLL_PFD1:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ENCODER,
                    1, PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_ARMPLL_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_ARM,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD0_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 0U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD0:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 0U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD1_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 1U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD1:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 1U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD2_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 2U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD2:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 2U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD3_UNGATED:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 3U,
                    PLL_DFS_ENABLE_MASK);
                break;

            case CLOCK_SRC_ARMPLL_PFD3:
                clkEnable = FRACTPLL_GetDfsEnable(CLOCK_PLL_ARM, 3U,
                    PLL_DFS_CLKOUT_EN_MASK);
                break;

            case CLOCK_SRC_DRAMPLL_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_DRAM,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_DRAMPLL:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_DRAM,
                    PLL_CTRL_CLKMUX_EN_MASK);
                break;

            case CLOCK_SRC_HSIOPLL_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_HSIO,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_HSIOPLL:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_HSIO,
                    PLL_CTRL_CLKMUX_EN_MASK);
                break;

            case CLOCK_SRC_LDBPLL_VCO:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_LDB,
                    PLL_CTRL_POWERUP_MASK);
                break;

            case CLOCK_SRC_LDBPLL:
                clkEnable = FRACTPLL_GetEnable(CLOCK_PLL_LDB,
                    PLL_CTRL_CLKMUX_EN_MASK);
                break;

            case CLOCK_SRC_EXT1:
                clkEnable = true;
                break;

            default:
                ; /* Intentional empty default */
                break;
        }
    }

    return clkEnable;
}

/*--------------------------------------------------------------------------*/
/* Set CCM clock source enable                                              */
/*--------------------------------------------------------------------------*/
bool CLOCK_SourceSetEnable(uint32_t sourceIdx, bool enable)
{
    bool updateEnable = false;

    if (CLOCK_SourcePdIsOn(sourceIdx))
    {
        switch(sourceIdx)
        {
            case CLOCK_SRC_OSC32K:
                updateEnable = true;
                break;

            case CLOCK_SRC_OSC24M:
                updateEnable = true;
                break;

            case CLOCK_SRC_SYSPLL1_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_SYS1,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD0_DIV2:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 0U,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 1U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 1U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD1_DIV2:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 1U,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_SYSPLL1_PFD2_DIV2:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_SYS1, 2U,
                    PLL_DFS_CLKOUT_DIVBY2_EN_MASK, enable);
                break;

            case CLOCK_SRC_AUDIOPLL1_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_AUDIO1,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_AUDIOPLL1:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_AUDIO1,
                    PLL_CTRL_CLKMUX_EN_MASK, enable);
                break;

            case CLOCK_SRC_AUDIOPLL2_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_AUDIO2,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_AUDIOPLL2:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_AUDIO2,
                    PLL_CTRL_CLKMUX_EN_MASK, enable);
                break;

            case CLOCK_SRC_ENCPLL_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_ENCODER,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_ENCPLL_PFD0_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ENCODER, 0U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ENCPLL_PFD0:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ENCODER, 0U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_ENCPLL_PFD1_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ENCODER, 1U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ENCPLL_PFD1:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ENCODER, 1U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_ARM,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD0_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 0U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD0:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 0U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD1_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 1U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD1:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 1U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD2_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 2U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD2:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 2U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD3_UNGATED:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 3U,
                    PLL_DFS_ENABLE_MASK, enable);
                break;

            case CLOCK_SRC_ARMPLL_PFD3:
                updateEnable = FRACTPLL_SetDfsEnable(CLOCK_PLL_ARM, 3U,
                    PLL_DFS_CLKOUT_EN_MASK, enable);
                break;

            case CLOCK_SRC_DRAMPLL_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_DRAM,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_DRAMPLL:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_DRAM,
                    PLL_CTRL_CLKMUX_EN_MASK, enable);
                break;

            case CLOCK_SRC_HSIOPLL_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_HSIO,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_HSIOPLL:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_HSIO,
                    PLL_CTRL_CLKMUX_EN_MASK, enable);
                break;

            case CLOCK_SRC_LDBPLL_VCO:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_LDB,
                    PLL_CTRL_POWERUP_MASK, enable);
                break;

            case CLOCK_SRC_LDBPLL:
                updateEnable = FRACTPLL_SetEnable(CLOCK_PLL_LDB,
                    PLL_CTRL_CLKMUX_EN_MASK, enable);
                break;

            default:
                ; /* Intentional empty default */
                break;
        }
    }

    return updateEnable;
}

#else
status_t CLOCK_EnableClock(clock_ip_name_t clkId)
{
    uint32_t channel = SCMI_A2P;
    uint32_t clockId = (uint32_t)clkId;
    uint32_t attributes = SCMI_CLOCK_CONFIG_SET_ENABLE(SCMI_CLOCK_STATE_ENABLE);
    uint32_t oemConfigVal = 0U;
    int32_t result = SCMI_ERR_SUCCESS;
    status_t status = kStatus_Success;

    if (clkId == kCLOCK_IpInvalid)
    {
        return kStatus_InvalidArgument;
    }
    result = SCMI_ClockConfigSet(channel, clockId, attributes, oemConfigVal);
    if (result != SCMI_ERR_SUCCESS)
    {
        status = kStatus_Fail;
    }

    return status;
}

status_t CLOCK_DisableClock(clock_ip_name_t clkId)
{
    uint32_t channel = SCMI_A2P;
    uint32_t clockId = (uint32_t)clkId;
    uint32_t attributes = SCMI_CLOCK_CONFIG_SET_ENABLE(SCMI_CLOCK_STATE_DISABLE);
    uint32_t oemConfigVal = 0U;
    int32_t result = SCMI_ERR_SUCCESS;
    status_t status = kStatus_Success;

    if (clkId == kCLOCK_IpInvalid)
    {
        return kStatus_InvalidArgument;
    }
    result = SCMI_ClockConfigSet(channel, clockId, attributes, oemConfigVal);
    if (result != SCMI_ERR_SUCCESS)
    {
        status = kStatus_Fail;
    }

    return status;
}

status_t CLOCK_SetRate(clk_t *clk)
{
    uint32_t channel = SCMI_A2P;
    uint32_t clockId = (uint32_t)clk->clkId;
    uint32_t flags = SCMI_CLOCK_RATE_FLAGS_ROUND(clk->clkRoundOpt);
    scmi_clock_rate_t rate = {0, 0};
    int32_t result = SCMI_ERR_SUCCESS;
    status_t status = kStatus_Success;

    if (clk->clkId == kCLOCK_IpInvalid)
    {
        return kStatus_InvalidArgument;
    }
    rate.lower = clk->rate & 0xFFFFFFFF;
    rate.upper = (clk->rate >> 32U) & 0xFFFFFFFF;

    result = SCMI_ClockRateSet(channel, clockId, flags, rate);
    if (result != SCMI_ERR_SUCCESS)
    {
        status = kStatus_Fail;
    }

    return status;
}

uint64_t CLOCK_GetRate(clock_ip_name_t clkId)
{
    scmi_clock_rate_t rate = {0, 0};
    uint32_t channel = SCMI_A2P;
    uint32_t clockId = (uint32_t)clkId;
    int32_t result = SCMI_ERR_SUCCESS;

    if (clkId == kCLOCK_IpInvalid)
    {
        return 0ULL;
    }

    result = SCMI_ClockRateGet(channel, clockId, &rate);
    if (result != SCMI_ERR_SUCCESS)
    {
        return 0ULL;
    }

    return rate.lower | ((uint64_t)(rate.upper) << 32U);
}

status_t CLOCK_SetParent(clk_t *clk)
{
    uint32_t channel = SCMI_A2P;
    uint32_t clockId = (uint32_t)clk->clkId;
    uint32_t parentId = (uint32_t)clk->pclkId;
    int32_t result = SCMI_ERR_SUCCESS;
    status_t status = kStatus_Success;

    if (clk->clkId == kCLOCK_IpInvalid || clk->pclkId == kCLOCK_IpInvalid)
    {
        return kStatus_InvalidArgument;
    }

    result = SCMI_ClockParentSet(channel, clockId, parentId);
    if (result != SCMI_ERR_SUCCESS)
    {
        status = kStatus_Fail;
    }

    return status;
}

#endif

