/** @file wps_msg.c
 *
 *  @brief This file contains WPS Messages processing functions
 *
 *  Copyright 2008-2022 NXP
 *
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "wifi_nxp_wps.h"
#include <lwip/inet.h>
#include <wm_os.h>
#include "wmcrypto.h"

#include "wps_mem.h"
#include "wps_msg.h"
#include "wps_eapol.h"
#include "wps_def.h"
#include "wps_wlan.h"
#include "wps_os.h"

/** WPS global */
extern WPS_DATA wps_global;
extern struct wlan_network wps_network;
extern u8 *g_bssid;
extern u8 g_channel;

/** Global pwps information */
extern PWPS_INFO gpwps_info;

#ifdef CONFIG_WPA2_ENTP
#define CONFIG_EAP_TLS
extern bool gpwps_info_initialized;
#endif

/** IE index*/
extern short ie_index;
/** IE buffer index */
extern short ap_assocresp_ie_index;
/********************************************************
        Local Variables
********************************************************/
/** Enrollee identity */
static const char wps_enrollee_identity[] = "WFA-SimpleConfig-Enrollee-1-0";
/** Registrar identity */
static const char wps_registrar_identity[] = "WFA-SimpleConfig-Registrar-1-0";
/** WPS vendor ID */
static u8 wps_vendor_id[3] = {0x00, 0x37, 0x2A};

/** WPS vendor type */
static u8 wps_vendor_type[4] = {0x00, 0x00, 0x00, 0x01};

/** WPS OUI */
static u8 wps_wifi_oui[4] = {0x00, 0x50, 0xF2, 0x04};

/** Prime value in Diffie-Hellman Exchange */
static u8 DH_PRIME_1536[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34, 0xC4, 0xC6,
    0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74, 0x02, 0x0B, 0xBE, 0xA6,
    0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD, 0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A,
    0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37, 0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6, 0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF,
    0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED, 0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11,
    0x7C, 0x4B, 0x1F, 0xE6, 0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63,
    0xBF, 0x05, 0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB, 0x9E, 0xD5,
    0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04, 0xF1, 0x74, 0x6C, 0x08,
    0xCA, 0x23, 0x73, 0x27, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

/** Generator in Diffie-Hellman Exchange */
static u8 GEN = 0x2;
/** Key generated by Diffie-Hellman Exchange */
static u8 DHKey[SHA256_DIGEST_SIZE] PM3_BSS;

/** Key derived by EnrolleeMAC and Nonce */
static u8 KDK[SHA256_DIGEST_SIZE] PM3_BSS;

/** Key wrapped authenticator */
static u8 KWA[SHA256_DIGEST_SIZE] PM3_BSS;

/** Additional Key : AuthKey(32B)+KeyWrapKey(16B)+EMSK(32B) */
#define AUTH_KEY_LEN 256 / 8
#define KWK_LEN      128 / 8
#define EMSK_LEN     256 / 8
#define PSK_LEN      128 / 8

static u8 AKE_Key[AUTH_KEY_LEN + KWK_LEN + EMSK_LEN] PM3_BSS;

/** First 128 bits of hashed 1st/2nd half of device password */
static u8 PSK1[PSK_LEN] PM3_BSS;
static u8 PSK2[PSK_LEN] PM3_BSS;

/* ES1(16B)+PSK1(16B)+PKE(192B)+PKR(192B) = 416B */
static u8 HashArgu[416] PM3_BSS;
/* N1(16B)+MAC(6B)+N2(16B) = 38B */
static u8 HashKdkIn[38] PM3_BSS;
static u8 EncryData[0x200] PM3_BSS;
/* Output buffer for AEC-CBC Encryption */
static u8 EncryAesOutput[0x200] PM3_BSS;

#define WPS_VENDOR_EXT_ID_LEN (3)
static const char wfa_vendor_ext_id[WPS_VENDOR_EXT_ID_LEN] = {0x00, 0x37, 0x2A};

static int num_cred = 1;

#define WPS_SAVE_PKT(i, f, l)                        \
    do                                               \
    {                                                \
        (void)memcpy(i->last_message.message, f, l); \
        i->last_message.length = l;                  \
    } while (0)

#define WPS_EAPOL_TX_AND_SAVE(r, i, d, b, s)                                                    \
    do                                                                                          \
    {                                                                                           \
        r = wps_eapol_txPacket((u8 *)b, s);                                                     \
        if (r >= 0)                                                                             \
        {                                                                                       \
            WPS_SAVE_PKT(i, (u8 *)(((PEAP_FRAME_HEADER)(b)) + 1), s - SZ_EAP_WPS_FRAME_HEADER); \
        }                                                                                       \
    } while (0)

static int wps_authenticator_generate(
    PWPS_INFO pwps_info, u8 *prev_msg, u16 prev_msg_len, u8 *curr_msg, u16 curr_msg_len, u8 *hmac_out);
short wps_selected_registrar_config_method_prepare(PWPS_INFO pwps_info);
int wps_config_read(PWPS_INFO pwps_info, WPS_DATA *wps_s);
void wps_generate_uuid_using_mac_addr(const u8 *mac_addr, u8 *uuid);

/********************************************************
        Global Variables
********************************************************/

/********************************************************
        Local Functions
********************************************************/
/**
 * @brief  Find key length
 * @param a      Key
 * @param digits sizeof key
 * @return       key length
 */
unsigned int N8_Digits(u8 *a, u32 digits)
{
    unsigned int i;

    for (i = 0; i < digits; i++)
    {
        if (a[i])
            break;
    }

    return digits - i;
}

/**
 *  @brief  Prepare for EAP message header
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param code         EAP_RESPONSE or EAP_REQUEST
 *  @param id           Frame identifier
 *  @param wps_msg      EAP packet Op-Code
 *  @return             Length of EAP message header
 */
static int wps_eap_message_header_prepare(PWPS_INFO wps_info, u8 code, u8 id, u8 wps_msg)
{
    PEAP_FRAME_HEADER peap_wps_frame;

    ENTER();

    peap_wps_frame             = (PEAP_FRAME_HEADER)wps_info->buffer;
    peap_wps_frame->code       = code;
    peap_wps_frame->identifier = id;
    peap_wps_frame->type       = EAP_TYPE_WPS; /* 254 */
    peap_wps_frame->length     = SZ_EAP_WPS_FRAME_HEADER;
    (void)memcpy(peap_wps_frame->vendor_id, wps_vendor_id, sizeof(wps_vendor_id));
    (void)memcpy(peap_wps_frame->vendor_type, wps_vendor_type, sizeof(wps_vendor_type));
    peap_wps_frame->op_code = wps_msg;
    peap_wps_frame->flags   = 0;

    LEAVE();
    return SZ_EAP_WPS_FRAME_HEADER;
}

/**
 *  @brief  Prepare for WPS Version Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_version_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    /* The Version attr is deprecated in WSC2.0, so hardcode a value of 0x10
       for backward compatibility */
    u8 version = WPS_VERSION_1DOT0;
    PTLV_DATA_HEADER ptlv;
    int offset;
    ENTER();

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Version);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;

    (void)memcpy(ptr, &version, ptlv->length);

    ptr += ptlv->length;
    offset = SZ_TLV_HEADER + ptlv->length;

    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Version2 Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_subele_version2_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    PSUBELE_DATA_HEADER pele;
    int offset;

    ENTER();

    pele         = (PSUBELE_DATA_HEADER)ptr;
    pele->type   = SC_Version2;
    pele->length = SZ_VERSION2;
    ptr += SZ_SUBELE_HEADER;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
    {
        wps_d("Sending Version2 as 0x%x!\n", pwps_info->enrollee.version);
        (void)memcpy(ptr, &pwps_info->enrollee.version, pele->length);
    }
    else if (pwps_info->role == WPS_REGISTRAR || (IS_DISCOVERY_REGISTRAR(pwps_info)))
    {
        (void)memcpy(ptr, &pwps_info->registrar.version, pele->length);
    }

    offset = SZ_SUBELE_HEADER + pele->length;

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Authorized MACs Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_subele_authorized_mac_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    PSUBELE_DATA_HEADER pele;
    int offset;
    u8 wps_zero_mac[]      = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    u8 wps_broadcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    u8 auth_enrollee_count = 0, authorized_enrollee_present = 0, authorized_enrollee_present_count = 0;
    ENTER();

    pele         = (PSUBELE_DATA_HEADER)ptr;
    pele->type   = SC_AuthorizedMACs;
    pele->length = 0;
    ptr += SZ_SUBELE_HEADER;
    authorized_enrollee_present = WPS_CANCEL;
    while (auth_enrollee_count < MAX_AUTH_ENROLLEE_COUNT)
    {
        if (memcmp(&pwps_info->auth_enrollee_mac_addr[auth_enrollee_count * ETH_ALEN], wps_zero_mac, ETH_ALEN))
        {
            (void)memcpy(ptr, &pwps_info->auth_enrollee_mac_addr[auth_enrollee_count * ETH_ALEN], ETH_ALEN);
            wps_hexdump("Authorized Enrollee Mac address: ",
                        &pwps_info->auth_enrollee_mac_addr[auth_enrollee_count * ETH_ALEN], ETH_ALEN);
            wps_d("Count %d ", auth_enrollee_count);
            pele->length += ETH_ALEN;
            ptr += ETH_ALEN;
            authorized_enrollee_present = WPS_SET;
            authorized_enrollee_present_count++;
        }
        auth_enrollee_count++;
    }
    if (authorized_enrollee_present == WPS_CANCEL)
    {
        (void)memcpy(ptr, wps_broadcast_mac, ETH_ALEN);
        pele->length += ETH_ALEN;
    }
    offset = SZ_SUBELE_HEADER + pele->length;

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Vendor extension Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_vendor_ext_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;

    ENTER();

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Vendor_Extension);
    ptlv->length = 0;
    ptr += SZ_TLV_HEADER;

    LEAVE();
    return SZ_TLV_HEADER;
}

/**
 *  @brief  Prepare for WPS Message type Attribute
 *
 *  @param ptr          A pointer to buffer which store this attribute
 *  @param msg_id       WPS Message Type
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_message_type_prepare(u8 *ptr, u8 msg_id)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Message_Type);
    ptlv->length = 1;

    ptr += SZ_TLV_HEADER;
    *ptr   = msg_id;
    offset = SZ_TLV_HEADER + ptlv->length;

    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS UUID Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_uuid_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv = (PTLV_DATA_HEADER)ptr;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
    {
        ptlv->type   = htons(SC_UUID_E);
        ptlv->length = pwps_info->enrollee.wps_uuid_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.wps_uuid, ptlv->length);
    }
    else if (pwps_info->role == WPS_REGISTRAR || (IS_DISCOVERY_REGISTRAR(pwps_info)))
    {
        ptlv->type   = htons(SC_UUID_R);
        ptlv->length = pwps_info->registrar.wps_uuid_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->registrar.wps_uuid, ptlv->length);
    }

    offset       = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS MAC Address Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_mac_address_prepare(PWPS_INFO wps_info, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_MAC_Address);
    ptlv->length = sizeof(wps_info->enrollee.mac_address);
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, wps_info->enrollee.mac_address, ptlv->length);

    offset       = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Nonce Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param type         WPS_ENROLLEE or WPS_REGISTRAR
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_nonce_prepare(PWPS_INFO pwps_info, u8 type, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;
    u8 *nonce;

    ENTER();

    ptlv = (PTLV_DATA_HEADER)ptr;

    if (type == WPS_ENROLLEE)
    {
        ptlv->type = htons(SC_Enrollee_Nonce);
        nonce      = pwps_info->enrollee.nonce;
    }
    else
    {
        ptlv->type = htons(SC_Registrar_Nonce);
        nonce      = pwps_info->registrar.nonce;
    }

    ptlv->length = WPS_NONCE_SIZE;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, nonce, ptlv->length);
    offset       = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Public Key Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param type         WPS_ENROLLEE or WPS_REGISTRAR
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_public_key_prepare(PWPS_INFO pwps_info, u8 type, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;
    DH_PG_PARAMS params;

    ENTER();

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Public_Key);
    ptlv->length = SZ_PUBLIC_KEY;

    /* Get Fiffie-Hellman Public Key */
    params.generator    = &GEN;
    params.generatorLen = 1;
    params.prime        = DH_PRIME_1536;
    params.primeLen     = sizeof(DH_PRIME_1536);

    if (type == WPS_ENROLLEE)
    {
        (void)memset(pwps_info->enrollee.public_key, 0, SZ_PUBLIC_KEY);
        (void)memset(pwps_info->enrollee.private_key, 0, SZ_PRIVATE_KEY);
        /* in a case that the WPS fails and restarts,       */
        /* free the old DH first before starting the new DH */
        nxp_dh_free(pwps_info->dh);
        pwps_info->dh = nxp_dh_setup_key(pwps_info->enrollee.public_key, SZ_PUBLIC_KEY, pwps_info->enrollee.private_key,
                                         SZ_PRIVATE_KEY, &params);

        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.public_key, ptlv->length);
    }
    else if (type == WPS_REGISTRAR)
    {
        (void)memset(pwps_info->registrar.public_key, 0, SZ_PUBLIC_KEY);
        (void)memset(pwps_info->registrar.private_key, 0, SZ_PRIVATE_KEY);
        /* in a case that the WPS fails and restarts,       */
        /* free the old DH first before starting the new DH */
        nxp_dh_free(pwps_info->dh);
        pwps_info->dh = nxp_dh_setup_key(pwps_info->registrar.public_key, SZ_PUBLIC_KEY,
                                         pwps_info->registrar.private_key, SZ_PRIVATE_KEY, &params);

        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->registrar.public_key, ptlv->length);
    }

    offset       = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Primary Device Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int wps_attribute_primary_device_type_prepare(PWPS_INFO pwps_info, u8 *ptr)
{
    PRIMARY_DEVICE_TYPE_MSG *primary_dev;
    int offset;

    ENTER();

    primary_dev                  = (PRIMARY_DEVICE_TYPE_MSG *)ptr;
    primary_dev->type            = htons(SC_Primary_Device_Type);
    primary_dev->length          = SZ_PRIMARY_DEVICE_TYPE;
    primary_dev->category_id     = htons(pwps_info->primary_dev_category);
    primary_dev->sub_category_id = htons(pwps_info->primary_dev_subcategory);
    (void)memcpy(primary_dev->oui_id, wps_wifi_oui, sizeof(wps_wifi_oui));

    offset              = SZ_TLV_HEADER + primary_dev->length;
    primary_dev->length = htons(primary_dev->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Prepare for WPS Attribute including Version, Message Type, Nonce
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param id           Frame identifier
 *  @param code         EAP_RESPONSE or EAP_REQUEST
 *  @param opCode       EAP packet Op-Code
 *  @param message_type WPS Message Type
 *  @return             Length of Attribute TLV
 */
static int wps_message_common_attribute_prepare(PWPS_INFO pwps_info, u8 id, u8 code, u8 opCode, u8 message_type)
{
    int offset = 0;
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 message_length;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;

    offset         = wps_eap_message_header_prepare(pwps_info, code, id, opCode);
    message_length = 0;

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, message_type);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    offset = wps_attribute_nonce_prepare(pwps_info, WPS_ENROLLEE, ptr);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    offset = wps_attribute_nonce_prepare(pwps_info, WPS_REGISTRAR, ptr);
    message_length += offset;

    peap_wps_frame->length += message_length;
    message_length         = peap_wps_frame->length;
    peap_wps_frame->length = htons(message_length);

    LEAVE();
    return message_length;
}

/**
 *  @brief  Prepare for WPS Authenticator Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param message_len  Length before authenticator
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static u16 wps_attribute_authenticator_prepare(PWPS_INFO pwps_info, u16 message_len, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u16 offset     = 0;
    u8 hmacOut[32] = {0};

    ENTER();

    /* Generate 32-byte Authenticator */
    wps_authenticator_generate(pwps_info, pwps_info->last_message.message, pwps_info->last_message.length,
                               pwps_info->buffer + SZ_EAP_WPS_FRAME_HEADER, message_len, hmacOut);

    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Authenticator);
    ptlv->length = SZ_AUTHENTICATOR;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, hmacOut, SZ_AUTHENTICATOR);
    offset = SZ_TLV_HEADER + SZ_AUTHENTICATOR;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/**
 *  @brief  Generate WPS Authenticator
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param prev_msg     A pointer to previous WPS message
 *  @param prev_msg_len Length of previous WPS message
 *  @param curr_msg     A pointer to current WPS message
 *  @param curr_msg_len Length of current WPS message
 *  @param hmac_out     A pointer to buffer which stores authenticator
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
static int wps_authenticator_generate(
    PWPS_INFO pwps_info, u8 *prev_msg, u16 prev_msg_len, u8 *curr_msg, u16 curr_msg_len, u8 *hmac_out)
{
    u8 *hmacIn;
    u16 hmacLen = 0;

    ENTER();

    if ((prev_msg_len + curr_msg_len) > 2048)
    {
        wps_d("ERROR : mac buffer is small!\n");
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    hmacIn = (u8 *)wps_mem_malloc(2048);
    if (hmacIn == NULL)
    {
        wps_d("ERROR : malloc failed !\n");
        LEAVE();
        return WPS_STATUS_FAIL;
    }
    (void)memset(hmacIn, 0, 2048);

    hmacLen = prev_msg_len;
    (void)memcpy(hmacIn, prev_msg, prev_msg_len);
    (void)memcpy((u8 *)(hmacIn + prev_msg_len), curr_msg, curr_msg_len);
    hmacLen += curr_msg_len;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, hmacIn, hmacLen, hmac_out, SHA256_DIGEST_SIZE);

    wps_mem_free(hmacIn);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

#define PROTO_STR_LEN         10
#define KEY_MGMT_STR_LEN      20
#define PAIRWISE_STR_LEN      30
#define PSK_STR_LEN           65
#define WEP_KEY_INDEX_STR_LEN 10
#define WEP_TX_KEYIDX_STR_LEN 20
#define WEP_KEY_STR_LEN       30

/**
 *  @brief  Write Network Credential to output file
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param stream       File pointer to be write to
 *  @param index        Index of credential array
 *  @param nCred        Credential number for mixed mode security
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
int output_supp_config(PWPS_INFO pwps_info, int index, int nCred)
{
    CREDENTIAL_DATA *pCredential;
    int ret         = WPS_STATUS_SUCCESS;
    int i           = 0;
    int psk_written = 0, eap_written = 0;
    int wpa_written = 0, rsn_written = 0;
    u16 auth;
    u16 encry;
    WPS_DATA *wps_s                    = (WPS_DATA *)&wps_global;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = NULL;
    char proto_str[PROTO_STR_LEN];
    char key_mgmt_str[KEY_MGMT_STR_LEN];
    char pairwise_str[PAIRWISE_STR_LEN];
    char psk_str[PSK_STR_LEN];
    char wep_key_index_str[WEP_KEY_INDEX_STR_LEN];
    char wep_key_str[WEP_KEY_STR_LEN];
    char wep_tx_keyidx_str[WEP_TX_KEYIDX_STR_LEN];

    ENTER();
    (void)memset(&(wps_global.wps_conn_network), 0, sizeof(struct wlan_network));
    wps_global.wps_conn_network.ssid_specific     = 1;
    wps_global.wps_conn_network.ip.ipv4.addr_type = ADDR_TYPE_DHCP;

    if ((wps_s->bss_type == BSS_TYPE_STA) && (pwps_info->read_ap_config_only == WPS_SET))
    {
        pCredential = (CREDENTIAL_DATA *)&pwps_info->enrollee.cred_data[index];
        en_reg      = &pwps_info->enrollee;
    }
    else
    {
        pCredential = (CREDENTIAL_DATA *)&pwps_info->registrar.cred_data[index];
        en_reg      = &pwps_info->registrar;
    }

    wps_d("Create config file for wpa_supplicant\r\n");
    wps_d("Auth Type: %x, Encryption Type: %x\r\n\r\n", pCredential->auth_type, pCredential->encry_type);

    if (pCredential->auth_type == AUTHENTICATION_TYPE_WPAPSK || pCredential->auth_type == AUTHENTICATION_TYPE_WPA ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA2 || pCredential->auth_type == AUTHENTICATION_TYPE_WPA_MIXED ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA2PSK)
    {
        /* Checking incorrect combination for Auth/Encry pair */
        if ((pCredential->encry_type == ENCRYPTION_TYPE_NONE) || (pCredential->encry_type == ENCRYPTION_TYPE_WEP))
        {
            PRINTF(
                "ERROR: Fail to generate wps.conf due to unexpected "
                "Auth Type (0x%x) and Encryption Type (0x%x)!\r\n",
                pCredential->auth_type, pCredential->encry_type);
            LEAVE();
            return WPS_STATUS_FAIL;
        }

        (void)memcpy(wps_global.wps_conn_network.name, pCredential->ssid, pCredential->ssid_length);
        (void)memcpy(wps_global.wps_conn_network.ssid, pCredential->ssid, pCredential->ssid_length);

        /* proto */
        for (i = 0; i < nCred; i++)
        {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[index];

            auth = pCredential->auth_type;
            switch (auth)
            {
                case AUTHENTICATION_TYPE_WPAPSK: /* 0x0002 */
                case AUTHENTICATION_TYPE_WPA:    /* 0x0008 */
                    if (wpa_written)
                        break;
                    sprintf(proto_str, "%s", "WPA");
                    wps_global.wps_conn_network.security.type = WLAN_SECURITY_WPA;
                    wpa_written                               = 1;
                    break;

                case AUTHENTICATION_TYPE_WPA2:    /* 0x0010 */
                case AUTHENTICATION_TYPE_WPA2PSK: /* 0x0020 */
                    if (rsn_written)
                        break;
                    sprintf(proto_str, "%s", "RSN");
                    wps_global.wps_conn_network.security.type = WLAN_SECURITY_WPA2;
                    rsn_written                               = 1;
                    break;
                case AUTHENTICATION_TYPE_WPA_MIXED: /* 0x0022 */
                    /* For Mixed mode, force WPA2 */
                    if (rsn_written)
                        break;
                    sprintf(proto_str, "%s", "RSN");
                    wps_global.wps_conn_network.security.type = WLAN_SECURITY_WPA_WPA2_MIXED;
                    rsn_written                               = 1;
                    break;
                default:
                    sprintf(proto_str, "%s", " ");
                    break;
            }
        }

        /* key_mgmt */
        for (i = 0; i < nCred; i++)
        {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[index];

            auth = pCredential->auth_type;
            switch (auth)
            {
                case AUTHENTICATION_TYPE_WPAPSK:    /* 0x0002 */
                case AUTHENTICATION_TYPE_WPA2PSK:   /* 0x0020 */
                case AUTHENTICATION_TYPE_WPA_MIXED: /* 0x0022 */
                    if (psk_written)
                        break;
                    if (pCredential->encry_type == ENCRYPTION_TYPE_NONE)
                        sprintf(key_mgmt_str, "%s", "WPA-NONE");
                    else
                        sprintf(key_mgmt_str, "%s", "WPA-PSK");
                    psk_written = 1;
                    break;

                case AUTHENTICATION_TYPE_WPA:  /* 0x0008 */
                case AUTHENTICATION_TYPE_WPA2: /* 0x0010 */
                    if (eap_written)
                        break;
                    sprintf(key_mgmt_str, "%s", "WPA-EAP");
                    eap_written = 1;
                    break;

                default:
                    sprintf(key_mgmt_str, "%s", " ");
                    break;
            }
        }

        /* pairwise */
        for (i = 0; i < nCred; i++)
        {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[index];

            encry = pCredential->encry_type;
            switch (encry)
            {
                case ENCRYPTION_TYPE_WEP: /* 0x0002 */
                    sprintf(pairwise_str, "%s", "WEP40 WEP104");
                    break;
                case ENCRYPTION_TYPE_TKIP: /* 0x0004 */
                    sprintf(pairwise_str, "%s", "TKIP");
                    break;
                case ENCRYPTION_TYPE_AES: /* 0x0008 */
                    sprintf(pairwise_str, "%s", "CCMP");
                    break;
                case ENCRYPTION_TYPE_TKIP | ENCRYPTION_TYPE_AES:
                    sprintf(pairwise_str, "%s", "TKIP CCMP");
                    break;
                case ENCRYPTION_TYPE_NONE:
                    sprintf(pairwise_str, "%s", "NONE");
                    break;
                default:
                    sprintf(pairwise_str, "%s", " ");
                    break;
            }
        }

        pCredential = (CREDENTIAL_DATA *)&en_reg->cred_data[index];

        wps_global.wps_conn_network.security.psk_len = pCredential->network_key_len;
        (void)memcpy(wps_global.wps_conn_network.security.psk, pCredential->network_key, pCredential->network_key_len);

        snprintf(psk_str, pCredential->network_key_len + 1, "%s", pCredential->network_key);

        if (pCredential->network_key_len == 64)
        {
            wps_d(
                "network = {ssid=\"%s\", proto=%s, key_mgmt=%s,"
                " pairwise=%s, ",
                pCredential->ssid, proto_str, key_mgmt_str, pairwise_str);
            wps_d("psk=%s}", psk_str);
        }
        else
        {
            wps_d(
                "network = {ssid=\"%s\", proto=%s, key_mgmt=%s,"
                " pairwise=%s, psk=\"%s\"}",
                pCredential->ssid, proto_str, key_mgmt_str, pairwise_str, psk_str);
        }
    }
    else if (pCredential->auth_type == AUTHENTICATION_TYPE_OPEN || pCredential->auth_type == AUTHENTICATION_TYPE_SHARED)
    {
        /* Checking incorrect combination for Auth/Encry pair */
        if (pCredential->encry_type == ENCRYPTION_TYPE_TKIP || pCredential->encry_type == ENCRYPTION_TYPE_AES)
        {
            PRINTF(
                "ERROR: Fail to generate wps.conf due to unexpected "
                "attribute combination! (auth=0x%x, encry=0x%x)\r\n",
                pCredential->auth_type, pCredential->encry_type);
            LEAVE();
            return WPS_STATUS_FAIL;
        }

        (void)memcpy(wps_global.wps_conn_network.name, pCredential->ssid, pCredential->ssid_length);
        (void)memcpy(wps_global.wps_conn_network.ssid, pCredential->ssid, pCredential->ssid_length);
        (void)memcpy(wps_global.wps_conn_network.bssid, wps_network.bssid, IEEEtypes_ADDRESS_SIZE);

        if (pCredential->encry_type == ENCRYPTION_TYPE_WEP)
        {
            /* WEP Key */
            /*
             * Note : WEP Key Index of wpa_supplicant
             * is "0" based index, but we use "1" based
             * index here for Buffalo AP issue
             */
            /*
             * If WEP transmit key is available,
             * use it for configuration.
             */
            if (pCredential->wep_tx_key_index)
            {
                /* WEP Key Index of wpa_supplicant
                   is "0" based index */
                sprintf(wep_key_index_str, "%s%d=", "wep_key", pCredential->wep_tx_key_index - 1);
            }
            else if (pCredential->network_key_index)
            {
                /* WEP Key Index of wpa_supplicant
                   is "0" based index */
                sprintf(wep_key_index_str, "%s%d=", "wep_key", pCredential->network_key_index - 1);
            }

            /*
             * Length of Key is 10 or 26 implies
             * that data is HEX character.
             * Should ignore the quotation mark.
             */

            if (pCredential->network_key_len == 10 || pCredential->network_key_len == 26)
                sprintf(wep_key_str, "%s", pCredential->network_key);

            /* Length of Key is 5 or 13
               implies that data is ASCII character */
            /*
             * Buffalo AP will send 5 bytes data
             * (0x12-0x34-0x56-0x78-0x90)
             * in M8 message, but it's actually HEX Key value.
             * So we will convert 5 or 13 byte data
             * to HEX and output it
             * like wep_key0=1234567890.
             */
            else if (pCredential->network_key_len == 5)
            {
                sprintf(wep_key_str, "%02x%02x%02x%02x%02x", pCredential->network_key[0], pCredential->network_key[1],
                        pCredential->network_key[2], pCredential->network_key[3], pCredential->network_key[4]);
            }
            else if (pCredential->network_key_len == 13)
            {
                sprintf(wep_key_str,
                        "%02x%02x%02x%02x%02x%02x"
                        "%02x%02x%02x%02x%02x%02x%02x",
                        pCredential->network_key[0], pCredential->network_key[1], pCredential->network_key[2],
                        pCredential->network_key[3], pCredential->network_key[4], pCredential->network_key[5],
                        pCredential->network_key[6], pCredential->network_key[7], pCredential->network_key[8],
                        pCredential->network_key[9], pCredential->network_key[10], pCredential->network_key[11],
                        pCredential->network_key[12]);
            }

            /* Tx Key Index */
            if (pCredential->wep_tx_key_index)
            {
                /* Tx Key Index of wpa_supplicant
                   is "0" based index */
                sprintf(wep_tx_keyidx_str, "%s%d, ", "wep_tx_keyidx=", pCredential->wep_tx_key_index - 1);
            }
            else if (pCredential->network_key_index)
            {
                /* Tx Key Index of wpa_supplicant
                   is "0" based index */
                sprintf(wep_tx_keyidx_str, "%s%d, ", "wep_tx_keyidx=", pCredential->network_key_index - 1);
            }
        }
        PRINTF("\r\n");
        if (pCredential->auth_type == AUTHENTICATION_TYPE_SHARED)
            wps_d(
                "network = {ssid=\"%s\", key_mgmt=NONE, %s=%s, "
                "%s, auth_alg=SHARED}\r\n",
                pCredential->ssid, wep_key_index_str, wep_key_str, wep_tx_keyidx_str);
        else
            wps_d("network = {ssid=\"%s\", key_mgmt=NONE}\r\n", pCredential->ssid);
    }
    else
    {
        wps_d("ERROR: Unexpected Auth Type:: %0x !", pCredential->auth_type);
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return ret;
}

/**
 *  @brief  This function by default writes most secure network credentials
 *          in 2.4GHz band.
 *
 *          The index_g refers to most secure network credential in 2.4GHz band.
 *          The index_a refers to most secure network credential in 5GHz band.
 *
 *          Higher priority is given to 2.4GHz band credential, code can be
 *          modified as per credential requirements.
 *
 *          The appropriate index is passed to output_supp_config function which
 *          takes input, pointer to WPS_INFO structure, derived index and
 *          number of credentials that is 1.
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
int wps_write_credentials(PWPS_INFO pwps_info)
{
    int i, ret = WPS_STATUS_SUCCESS;
    int index_g = -1;
#ifdef CONFIG_5GHz_SUPPORT
    int index_a = -1;
#endif /* CONFIG_5GHz_SUPPORT */

    ENTER();

    /* To support Multi Radio AP */

    for (i = 0; i < num_cred; i++)
    {
        if (pwps_info->registrar.cred_data[i].rf_bands == 1)
        {
            index_g = i;
            break;
        }
    }

#ifdef CONFIG_5GHz_SUPPORT
    for (i = 0; i < num_cred; i++)
    {
        if (pwps_info->registrar.cred_data[i].rf_bands == 2)
        {
            index_a = i;
            break;
        }
    }
#endif /* CONFIG_5GHz_SUPPORT */

    for (i = 0; i < num_cred; i++)
    {
        if (index_g < 0)
        {
            break;
        }
        if ((pwps_info->registrar.cred_data[i].rf_bands == 1) &&
            (pwps_info->registrar.cred_data[i].auth_type >= pwps_info->registrar.cred_data[index_g].auth_type))
            index_g = i;

#ifdef CONFIG_5GHz_SUPPORT
        if (index_a < 0)
        {
            break;
        }
        if ((pwps_info->registrar.cred_data[i].rf_bands == 2) &&
            (pwps_info->registrar.cred_data[i].auth_type >= pwps_info->registrar.cred_data[index_a].auth_type))
            index_a = i;
#endif /* CONFIG_5GHz_SUPPORT */
    }

    if (index_g != -1)
        ret = output_supp_config(pwps_info, index_g, 1);
#ifdef CONFIG_5GHz_SUPPORT
    else if (index_a != -1)
        ret = output_supp_config(pwps_info, index_a, 1);
#endif /* CONFIG_5GHz_SUPPORT */
    else
    {
        /* Single Credential */
        ret = output_supp_config(pwps_info, 0, 1);
    }

    LEAVE();
    return ret;
}

/**
 *  @brief  Compute checksum value of PIN (8th digit of PIN)
 *
 *  @param PIN      PIN value
 *  @return         Checksum of PIN
 */
static int ComputeChecksum(unsigned long int PIN)
{
    u32 accum = 0;
    int digit;

    ENTER();

    PIN *= 10;
    accum += 3 * ((PIN / 10000000) % 10);
    accum += 1 * ((PIN / 1000000) % 10);
    accum += 3 * ((PIN / 100000) % 10);
    accum += 1 * ((PIN / 10000) % 10);
    accum += 3 * ((PIN / 1000) % 10);
    accum += 1 * ((PIN / 100) % 10);
    accum += 3 * ((PIN / 10) % 10);

    LEAVE();

    digit = (accum % 10);
    return (10 - digit) % 10;
}

/**
 *  @brief  Generate PIN value with random number generator
 *
 *  @return         PIN value
 */
int wps_generate_pin(uint32_t *pin)
{
    u32 ut;
    u32 wps_pin;

    ENTER();

    ut = os_ticks_get();
    srand(ut);

    wps_pin = rand() % 10000000;
    if (wps_pin < 1000000)
        wps_pin += 1000000;
    wps_pin = wps_pin * 10 + ComputeChecksum(wps_pin);

    *pin = wps_pin;

    LEAVE();

    return WM_SUCCESS;
}

/**
 *  @brief  Process Encryption type flags
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             Bitmask result of Encryption flags
 */
static inline int wps_process_encryption_type_flags(PWPS_INFO pwps_info)
{
    unsigned int encr_bit_mask = 0;
    encr_bit_mask              = pwps_info->enrollee.encry_type_flag & pwps_info->registrar.encry_type_flag;
    return encr_bit_mask;
}

/**
 *  @brief  Process Authentication type flags
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             Bitmask result of Authentication flags
 */
static inline int wps_process_authentication_type_flags(PWPS_INFO pwps_info)
{
    unsigned int auth_bit_mask = 0;
    auth_bit_mask              = pwps_info->enrollee.auth_type_flag & pwps_info->registrar.auth_type_flag;
    return auth_bit_mask;
}

/********************************************************
        Global Functions
********************************************************/
/**
 *  @brief  Prepare and Send EAP Identity Frame for EAP_RESPONSE
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_response_identity_prepare(PWPS_INFO pwps_info)
{
#ifdef CONFIG_WPA2_ENTP
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
#endif
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 length;
    int ret;
    const char *id_str = NULL;

    ENTER();

    peap_wps_frame             = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr                        = pwps_info->buffer;
    peap_wps_frame->code       = EAP_RESPONSE;
    peap_wps_frame->identifier = pwps_info->peer_id;
    peap_wps_frame->type       = EAP_TYPE_IDENTITY;
    peap_wps_frame->length     = 5;
    ptr += peap_wps_frame->length;

    if (pwps_info->prov_session == PROV_ENTP_SESSION_ATTEMPT)
    {
#ifdef CONFIG_EAP_TLS
        if (wps_s->wpa2_network.security.type == WLAN_SECURITY_EAP_TLS)
            id_str = wps_s->wpa2_network.identity;
#endif
#ifdef CONFIG_PEAP_MSCHAPV2
        if (wps_s->wpa2_network.security.type == WLAN_SECURITY_EAP_PEAP_MSCHAPV2)
            id_str = wps_s->wpa2_network.anonymous_identity;
#endif
    }
    else
    {
        id_str = ((pwps_info->role == WPS_ENROLLEE) || (IS_DISCOVERY_ENROLLEE(pwps_info)) ? wps_enrollee_identity :
                                                                                            wps_registrar_identity);
    }
    (void)memcpy(ptr, id_str, strlen(id_str));
    peap_wps_frame->length += strlen((char *)id_str);

    length                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;

    pwps_info->restart_by_M2D = WPS_CANCEL;

    return WPS_STATUS_SUCCESS;
}

#ifdef CONFIG_WPA2_ENTP
int wps_peap_response_identity_prepare(PWPS_INFO pwps_info)
{
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PEAP_FRAME_HEADER2 peap_frame;
    u8 eap_type;
    u16 length;
    int ret;
    const char *id_str = NULL;

    ENTER();

    peap_frame             = (PEAP_FRAME_HEADER2)pwps_info->buffer;
    peap_frame->code       = EAP_RESPONSE;
    peap_frame->identifier = pwps_info->peer_id;
    peap_frame->length     = sizeof(EAP_FRAME_HEADER2) + 1;

    eap_type = EAP_TYPE_IDENTITY;

    (void)memcpy((u8 *)peap_frame + sizeof(EAP_FRAME_HEADER2), &eap_type, sizeof(u8));

    id_str = wps_s->wpa2_network.identity;

    (void)memcpy((u8 *)peap_frame + sizeof(EAP_FRAME_HEADER2) + 1, id_str, strlen(id_str));
    peap_frame->length += strlen((const char *)id_str);

    length             = peap_frame->length;
    peap_frame->length = htons(peap_frame->length);

    /* call ssl write function */
    ret = wm_mbedtls_ssl_write(wps_s->wpa2_network.security.wlan_ssl, (u8 *)pwps_info->buffer + 4, (size_t)length - 4);
    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;

    return WPS_STATUS_SUCCESS;
}

#define EAP_FRAGMENT_SIZE 1024
/**
 *  @brief  Prepare and Send EAP Identity Frame for EAP_RESPONSE
 *
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_tls_response_send(const uint8_t *buf, const size_t len)
{
    mbedtls_ssl_context *wlan_ssl = wps_global.wpa2_network.security.wlan_ssl;
    PEAP_TLS_FRAME_HEADER peap_tls_frame;
    u8 *ptr;
    u16 length;
    int ret = WPS_STATUS_FAIL, ssl_state;

    ENTER();
    if (!wlan_ssl)
    {
        wps_d("%s ssl context failed", __func__);
        return WPS_STATUS_FAIL;
    }
    ssl_state = wlan_ssl->state - 1; /* "state" has moved to the next in mbedtls */

    if (gpwps_info_initialized)
    {
        if ((MBEDTLS_SSL_CLIENT_CERTIFICATE <= ssl_state) && (ssl_state <= MBEDTLS_SSL_CLIENT_FINISHED))
        {
            if (ssl_state == MBEDTLS_SSL_CLIENT_CERTIFICATE)
            {
                /* first fragment, initialize include_length & allocate certificate buffer */
                gpwps_info->include_length = 0;
                if (gpwps_info->more_frag_buffer)
                {
                    wps_mem_free(gpwps_info->more_frag_buffer);
                    gpwps_info->more_frag_buffer = NULL;
                }
                gpwps_info->more_frag_buffer = wps_mem_calloc(1, 4096);
                if (!gpwps_info->more_frag_buffer)
                {
                    wps_d("%s Not enough memory allocated !", __func__);
                    return WPS_STATUS_FAIL;
                }
            }
            ptr = gpwps_info->more_frag_buffer + gpwps_info->include_length;
            if (gpwps_info->include_length + len > 4096)
            {
                (void)PRINTF("eap-tls more_frag_buffer overflow, want=%d, actual=%d\r\n", gpwps_info->include_length + len, 4096);
                wps_mem_free(gpwps_info->more_frag_buffer);
                gpwps_info->more_frag_buffer = NULL;
                return WPS_STATUS_FAIL;
            }
            (void)memcpy(ptr, buf, len);
            gpwps_info->include_length += len;

            if (ssl_state == MBEDTLS_SSL_CLIENT_FINISHED)
            {
                int pos_len = 0, send_len = 0, retry_cnt;
                u32 *include_length;

                while (pos_len < gpwps_info->include_length)
                {
                    memset(gpwps_info->buffer, 0, sizeof(gpwps_info->buffer));
                    peap_tls_frame             = (PEAP_TLS_FRAME_HEADER)gpwps_info->buffer;
                    ptr                        = gpwps_info->buffer;
                    peap_tls_frame->code       = EAP_RESPONSE;
                    peap_tls_frame->identifier = gpwps_info->peer_id;
                    peap_tls_frame->type       = gpwps_info->eap_type;
                    peap_tls_frame->flags      = 0x00;
                    peap_tls_frame->length     = sizeof(EAP_TLS_FRAME_HEADER);
                    if (pos_len == 0) /* first fragment, add the include length */
                    {
                        peap_tls_frame->flags = 0x80;
                        include_length        = (u32 *)(ptr + sizeof(EAP_TLS_FRAME_HEADER));
                        *include_length       = htonl(gpwps_info->include_length);
                        peap_tls_frame->length += 4; /* 4-bytes for include_length */
                    }
                    ptr += peap_tls_frame->length;
                    if ((pos_len + EAP_FRAGMENT_SIZE) > gpwps_info->include_length)
                    {
                        /* last fragment */
                        send_len = gpwps_info->include_length - pos_len;
                    }
                    else
                    {
                        peap_tls_frame->flags |= 0x40; /* not last fragement, set more fragment bit */
                        send_len = EAP_FRAGMENT_SIZE;
                    }
                    (void)memcpy(ptr, gpwps_info->more_frag_buffer + pos_len, send_len);
                    peap_tls_frame->length += send_len;
                    pos_len += send_len;

                    length                 = peap_tls_frame->length;
                    peap_tls_frame->length = htons(peap_tls_frame->length);

                    /* call eapol tx function */
                    ret = wps_eapol_txPacket((u8 *)gpwps_info->buffer, (size_t)length);
                    if (ret < 0)
                    {
                        goto end_ret;
                    }

                    retry_cnt = 5;
                    do
                    {
                        if (peap_tls_frame->identifier == gpwps_info->peer_id)
                        {
                            wps_d("Sent certificate packet and wait EAPOL_REQUEST (identifier=%d not change)",
                                  peap_tls_frame->identifier);
                            retry_cnt--;
                            os_thread_sleep(200);
                        }
                        else
                            retry_cnt = 0;
                    } while (retry_cnt != 0);
                }
                goto end_ret;
            }
            else
            {
                /* Certificate handshake fragment does not finish, go to next state */
                return WPS_STATUS_SUCCESS;
            }
        }
        else
        {
            peap_tls_frame             = (PEAP_TLS_FRAME_HEADER)gpwps_info->buffer;
            ptr                        = gpwps_info->buffer;
            peap_tls_frame->code       = EAP_RESPONSE;
            peap_tls_frame->identifier = gpwps_info->peer_id;
            peap_tls_frame->type       = gpwps_info->eap_type;
            peap_tls_frame->flags      = 0x00;
            peap_tls_frame->length     = sizeof(EAP_TLS_FRAME_HEADER);

            if (buf && len)
            {
                ptr += peap_tls_frame->length;
                (void)memcpy(ptr, buf, len);
                peap_tls_frame->length += len;
            }
            length                 = peap_tls_frame->length;
            peap_tls_frame->length = htons(peap_tls_frame->length);

            /* call eapol tx function */
            ret = wps_eapol_txPacket((u8 *)gpwps_info->buffer, (size_t)length);
        }

    end_ret:
        if (gpwps_info->more_frag_buffer)
        {
            wps_mem_free(gpwps_info->more_frag_buffer);
            gpwps_info->more_frag_buffer = NULL;
        }
        LEAVE();

        if (ret < 0)
            return WPS_STATUS_FAIL;
    }
    return WPS_STATUS_SUCCESS;
}
#endif

/**
 *  @brief  Process EAP Identity Frame for EAP_RESPONSE
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Length of EAP Identity frame
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_response_identity_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)buf;
    wps_d("peap_wps_frame->identifier=0x%x, pwps_info->id=0x%x", peap_wps_frame->identifier, pwps_info->id);

    if (peap_wps_frame->identifier > (pwps_info->id))
        return WPS_STATUS_FAIL;

    buf += 5; /* point to identity string */
    size = ntohs(size);
    size -= 5;

    if (memcmp(buf, wps_registrar_identity, strlen((char *)wps_registrar_identity)) == 0)
    {
        wps_d("Peer device is Registrar");
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_REGISTRAR))
        {
            wps_d("Switching Role to Enrollee...");
            (void)memcpy(pwps_info->registrar.mac_address, pwps_info->enrollee.mac_address, ETH_ALEN);
            (void)memcpy(pwps_info->enrollee.mac_address, wps_s->my_mac_addr, ETH_ALEN);

            wps_hexdump("Enrollee Mac Address", pwps_info->enrollee.mac_address, ETH_ALEN);
            wps_hexdump("Registrar Mac Address", pwps_info->registrar.mac_address, ETH_ALEN);

            /* Read Device info from config file & generate UUID */
            /*wps_update_device_info(pwps_info, wps_s);*/

            /* Do this after config_read to avoid overwrite */
            pwps_info->role = WPS_ENROLLEE;
        }
    }
    else if (memcmp(buf, wps_enrollee_identity, strlen((char *)wps_enrollee_identity)) == 0)
    {
        wps_d("Peer device is Enrollee");
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE))
        {
            wps_d("Switching Role to Registrar...");
            (void)memcpy(pwps_info->enrollee.mac_address, pwps_info->registrar.mac_address, ETH_ALEN);
            (void)memcpy(pwps_info->registrar.mac_address, wps_s->my_mac_addr, ETH_ALEN);

            wps_hexdump("Enrollee Mac Address", pwps_info->enrollee.mac_address, ETH_ALEN);
            wps_hexdump("Registrar Mac Address", pwps_info->registrar.mac_address, ETH_ALEN);

            /* Read Device info from config file & generate UUID */
            /*wps_update_device_info(pwps_info, wps_s);*/

            /* Do this after config_read to avoid overwrite */
            pwps_info->role = WPS_REGISTRAR;
        }
    }
    else
    {
        wps_d("Unknown EAP Response Identity. Quitting");
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send EAP Identity Frame for EAP_REQUEST
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_request_identity_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 length;
    int ret;

    ENTER();

    peap_wps_frame             = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr                        = pwps_info->buffer;
    peap_wps_frame->code       = EAP_REQUEST;
    peap_wps_frame->identifier = pwps_info->id++;
    peap_wps_frame->type       = EAP_TYPE_IDENTITY;
    peap_wps_frame->length     = 5;
    ptr += peap_wps_frame->length;

    length                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;

    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process EAP Identity Frame for EAP_REQUEST
 *
 *  @param buf          A pointer to EAP frame
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_request_identity_process(u8 *buf)
{
    u8 *ptr;

    ENTER();

    ptr = (buf + 5);

    if (memcmp(ptr, wps_registrar_identity, strlen((char *)wps_registrar_identity)) != 0)
    {
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M1_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M1);
    message_length += offset;

    /* UUID-E */
    ptr += offset;
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* MAC Address */
    ptr += offset;
    offset = wps_attribute_mac_address_prepare(pwps_info, ptr);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Public Key */
    offset = wps_attribute_public_key_prepare(pwps_info, WPS_ENROLLEE, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.auth_type_flag);
    wps_d("M1 Auth type flags %4x", msg_value_short);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.encry_type_flag);
    wps_d("M1 Encry type flags %4x", msg_value_short);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.config_methods);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Simple Config State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;

    msg_value_char = SC_NOT_CONFIGURED_STATE;

    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Manufacturer);
    ptlv->length = pwps_info->enrollee.manufacture_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Name);
    ptlv->length = pwps_info->enrollee.model_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Number);
    ptlv->length = pwps_info->enrollee.model_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Serial_Number);
    ptlv->length = pwps_info->enrollee.serial_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Name);
    ptlv->length = pwps_info->enrollee.device_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, &pwps_info->enrollee.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.updated_device_password_id);

    wps_d("Enrollee DevID = 0x%x", msg_value_short);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->enrollee.os_version);
    (void)memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Subfunctoin: Process received vendor extension attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param data         A pointer to attribute
 *  @param length       actual length
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
static int wps_process_wfa_vendor_ext(PWPS_INFO pwps_info, u8 *data, u16 length)
{
    PSUBELE_DATA_HEADER pele;
    int ret                = WPS_STATUS_SUCCESS;
    u8 wps_broadcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    u8 offset = 0, auth_tlv_len = 0;
    u8 *data_end = data + length;
    MESSAGE_ENROLLEE_REGISTRAR *enr_reg;

    WPS_DATA *wps_s = &wps_global;
    ENTER();
    pele = (SUBELE_DATA_HEADER *)data;
    if (pwps_info->role == WPS_REGISTRAR)
    {
        enr_reg = &pwps_info->enrollee;
    }
    else
    {
        enr_reg = &pwps_info->registrar;
    }

    while ((void *)data < (void *)data_end)
    {
        switch (data[0])
        {
            case SC_Version2:
                (void)memcpy(&enr_reg->version2, data + 2, SZ_VERSION2);
                wps_d("Version2 = 0x%x", enr_reg->version2);
                break;

            case SC_AuthorizedMACs:
                pele         = (PSUBELE_DATA_HEADER)data;
                auth_tlv_len = pele->length;

                while (auth_tlv_len > 0)
                {
                    if (memcmp(wps_s->my_mac_addr, &data[2] + offset, ETH_ALEN) == 0 ||
                        memcmp(wps_broadcast_mac, &data[2] + offset, ETH_ALEN) == 0)
                    {
                        pwps_info->enrollee_in_authorized_mac = WPS_SET;
                        wps_d(
                            "Enrollee Mac address found"
                            " in Authorized Mac address list "
                            "of Registrar!");
                        goto done;
                    }
                    offset += ETH_ALEN;
                    auth_tlv_len -= ETH_ALEN;
                }
                pwps_info->enrollee_in_authorized_mac = WPS_CANCEL;
                wps_d(
                    "Enrollee Mac address not found in "
                    "Authorized Mac address list of Registrar!");
                break;

            default:
                wps_d("Unknown WFA Subele = 0x%x", data[0]);
                ret = WPS_STATUS_FAIL;
                goto done;
        }

        data += 2 + data[1];
    }

done:
    LEAVE();
    return ret;
}

/**
 *  @brief  Process received vendor extension attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param data         A pointer to attribute
 *  @param tlv_length   Length of TLV
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
static int wps_process_attrib_vendor_ext(PWPS_INFO pwps_info, u8 *data, u16 tlv_length)
{
    int ret = WPS_STATUS_SUCCESS;
    ENTER();
    if (tlv_length < WPS_VENDOR_EXT_ID_LEN)
    {
        ret = WPS_STATUS_FAIL;
        goto done;
    }
    if (!memcmp(data, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN))
    {
        ret = wps_process_wfa_vendor_ext(pwps_info, data + WPS_VENDOR_EXT_ID_LEN, tlv_length - WPS_VENDOR_EXT_ID_LEN);
    }

done:
    LEAVE();
    return ret;
}

/**
 *  @brief  Process received WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M1_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL, *pos;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;

    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->enrollee.version2 > WPS_VERSION)
                {
                    wps_d("(M1) Unknown WPS Version = 0x%x", pwps_info->enrollee.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M1)
                    return WPS_STATUS_FAIL;
                break;
            case SC_UUID_E:
                (void)memcpy(pwps_info->enrollee.wps_uuid, data, tlv_length);
                pwps_info->enrollee.wps_uuid_length = tlv_length;
                break;
            case SC_MAC_Address:
                if (memcmp(pwps_info->enrollee.mac_address, data, tlv_length) != 0)
                {
                    wps_d("Warning : Enrollee MAC Address Not Matched !");
                    wps_hexdump("SC_MAC_Address", data, tlv_length);
                    (void)memcpy(pwps_info->enrollee.mac_address, data, tlv_length);
                }
                else
                {
                    wps_d("INFO : Enrollee MAC Address Matched !");
                }
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Public_Key:
                (void)memcpy(pwps_info->enrollee.public_key, data, tlv_length);
                break;
            case SC_Authentication_Type_Flags:
                pos = ((u8 *)&pwps_info->enrollee + offsetof(MESSAGE_ENROLLEE_REGISTRAR, auth_type_flag));
                (void)memcpy(pos, data, tlv_length);
                pwps_info->enrollee.auth_type_flag = ntohs(pwps_info->enrollee.auth_type_flag);
                if (!wps_process_authentication_type_flags(pwps_info))
                {
                    wps_d(
                        "Authentication type flag from "
                        "Enrollee dont match with Registrar.\n");
                }
                break;
            case SC_Encryption_Type_Flags:
                pos = ((u8 *)&pwps_info->enrollee + offsetof(MESSAGE_ENROLLEE_REGISTRAR, encry_type_flag));
                (void)memcpy(pos, data, tlv_length);
                pwps_info->enrollee.encry_type_flag = ntohs(pwps_info->enrollee.encry_type_flag);
                if (!wps_process_encryption_type_flags(pwps_info))
                {
                    wps_d(
                        "Encryption type flag from Enrollee"
                        " dont match with Registrar.\n");
                }
                break;
            case SC_Connection_Type_Flags:
                (void)memcpy(&pwps_info->enrollee.connection_type_flag, data, tlv_length);
                break;
            case SC_Config_Methods:
                pos = ((u8 *)&pwps_info->enrollee + offsetof(MESSAGE_ENROLLEE_REGISTRAR, config_methods));
                (void)memcpy(pos, data, tlv_length);
                pwps_info->enrollee.config_methods = ntohs(pwps_info->enrollee.config_methods);
                break;
            case SC_Simple_Config_State:
                (void)memcpy(&pwps_info->enrollee.simple_config_state, data, tlv_length);
                break;
            case SC_Manufacturer:
                (void)memcpy(pwps_info->enrollee.manufacture, data, tlv_length);
                pwps_info->enrollee.manufacture_length = tlv_length;
                break;
            case SC_Model_Name:
                (void)memcpy(pwps_info->enrollee.model_name, data, tlv_length);
                pwps_info->enrollee.model_name_length = tlv_length;
                break;
            case SC_Model_Number:
                (void)memcpy(pwps_info->enrollee.model_number, data, tlv_length);
                pwps_info->enrollee.model_number_length = tlv_length;
                break;
            case SC_Serial_Number:
                (void)memcpy(pwps_info->enrollee.serial_number, data, tlv_length);
                pwps_info->enrollee.serial_number_length = tlv_length;
                break;
            case SC_Primary_Device_Type:
                (void)memcpy(pwps_info->enrollee.primary_device_type, data, tlv_length);
                break;
            case SC_Device_Name:
                (void)memcpy(pwps_info->enrollee.device_name, data, tlv_length);
                pwps_info->enrollee.device_name_length = tlv_length;
                break;
            case SC_RF_Band:
                (void)memcpy(&pwps_info->enrollee.rf_bands, data, tlv_length);
                break;
            case SC_Association_State:
                (void)memcpy(&pwps_info->enrollee.association_state, data, tlv_length);
                break;
            case SC_Device_Password_ID:
                pos = ((u8 *)&pwps_info->enrollee + offsetof(MESSAGE_ENROLLEE_REGISTRAR, device_password_id));
                (void)memcpy(pos, data, tlv_length);
                pwps_info->enrollee.device_password_id = ntohs(pwps_info->enrollee.device_password_id);
                break;
            case SC_Configuration_Error:
                (void)memcpy(&pwps_info->enrollee.configuration_error, data, tlv_length);
                pwps_info->enrollee.configuration_error = ntohs(pwps_info->enrollee.configuration_error);
                wps_d("SC_Configuration_Error(M1): %d", pwps_info->enrollee.configuration_error);
                break;
            case SC_OS_Version:
                pos = ((u8 *)&pwps_info->enrollee + offsetof(MESSAGE_ENROLLEE_REGISTRAR, os_version));
                (void)memcpy(pos, data, tlv_length);
                pwps_info->enrollee.os_version = ntohl(pwps_info->enrollee.os_version);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Validate Authenticator
 *
 *  @param wps_frm_body     A pointer to Received WPS frame body
 *  @param wps_frm_body_len Length of Received WPS frame body
 *  @return                 WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL
 *                on fail
 */
static int wps_authenticator_validate(PWPS_INFO pwps_info, u8 *wps_frm_body, u16 wps_frm_body_len)
{
    u8 hmacOut[32] = {0}, *rx_auth;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
    {
        rx_auth = pwps_info->registrar.authenticator;
    }
    else
    {
        rx_auth = pwps_info->enrollee.authenticator;
    }

    /* Generate 32-byte Authenticator */
    wps_authenticator_generate(pwps_info, pwps_info->last_message.message, pwps_info->last_message.length, wps_frm_body,
                               wps_frm_body_len - SZ_TLV_HEADER - SZ_AUTHENTICATOR, hmacOut);

    if (memcmp(rx_auth, hmacOut, SZ_AUTHENTICATOR))
    {
        wps_d("Rx packet: Invalid Authenticator!\n");
        wps_hexdump("RX'ed Authenticator", (u8 *)rx_auth, SZ_AUTHENTICATOR);
        wps_hexdump("Computed Authenticator", (u8 *)hmacOut, SZ_AUTHENTICATOR);
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Derive KDK
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
static int wps_derive_kdk(PWPS_INFO pwps_info)
{
    DH_PG_PARAMS params;
    u8 *agreed_key, *pub_key, *priv_key;
    size_t AgreedKeyLen;
    u32 shared_key_len;
    const u8 *msg[1];

    ENTER();

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
    {
        agreed_key = pwps_info->enrollee.agreed_key;
        pub_key    = pwps_info->registrar.public_key;
        priv_key   = pwps_info->enrollee.private_key;
    }
    else
    {
        agreed_key = pwps_info->registrar.agreed_key;
        pub_key    = pwps_info->enrollee.public_key;
        priv_key   = pwps_info->registrar.private_key;
    }

    /* DH Key Generation */
    params.generator    = &GEN;
    params.generatorLen = 1;
    params.prime        = DH_PRIME_1536;
    params.primeLen     = sizeof(DH_PRIME_1536);

    if (!pwps_info->dh)
        return WPS_STATUS_FAIL;

    shared_key_len = nxp_dh_compute_key(pwps_info->dh, agreed_key, WPS_AGREE_KEY_LEN, pub_key, WPS_PUB_KEY_LEN,
                                        priv_key, WPS_PRIV_KEY_LEN, &params);
    if (!shared_key_len)
        return WPS_STATUS_FAIL;

    nxp_dh_free(pwps_info->dh);
    pwps_info->dh = NULL;

    wps_hexdump("Agree Key", (u8 *)agreed_key, WPS_AGREE_KEY_LEN);

    AgreedKeyLen = N8_Digits(agreed_key, WPS_AGREE_KEY_LEN);
    wps_d("Agree Key Length = %d", AgreedKeyLen);

    (void)memset(DHKey, 0, sizeof(DHKey));
    msg[0] = &agreed_key[WPS_AGREE_KEY_LEN - AgreedKeyLen];
    if (!nxp_sha256_vector(1, msg, &AgreedKeyLen, DHKey, sizeof(DHKey)))
    {
        wps_d("SHA256 failed!\n");
        return WPS_STATUS_FAIL;
    }

    wps_hexdump("DH Key", (u8 *)DHKey, 32);

    /* Derivation of KDK */
    (void)memset(HashKdkIn, 0, sizeof(HashKdkIn));
    (void)memcpy(HashKdkIn, pwps_info->enrollee.nonce, WPS_NONCE_SIZE);
    (void)memcpy(HashKdkIn + 16, pwps_info->enrollee.mac_address, sizeof(pwps_info->enrollee.mac_address));
    (void)memcpy(HashKdkIn + 16 + 6, pwps_info->registrar.nonce, sizeof(pwps_info->registrar.nonce));

    /* Generate KDK Key */
    (void)memset(KDK, 0, sizeof(KDK));
    nxp_hmac_sha256(DHKey, SHA256_DIGEST_SIZE, HashKdkIn, sizeof(HashKdkIn), KDK, SHA256_DIGEST_SIZE);

    /* Generate Authentication Key, Key Wrap Key */
    (void)memset(AKE_Key, 0, sizeof(AKE_Key));
    nxp_kdf(KDK, SHA256_DIGEST_SIZE, AKE_Key, sizeof(AKE_Key));
    (void)memcpy(pwps_info->auth_key, AKE_Key, AUTH_KEY_LEN);
    (void)memcpy(pwps_info->key_wrap_key, AKE_Key + AUTH_KEY_LEN, KWK_LEN);
    (void)memcpy(pwps_info->emsk, AKE_Key + AUTH_KEY_LEN + KWK_LEN, EMSK_LEN);

    wps_hexdump("Auth Key", (u8 *)pwps_info->auth_key, sizeof(pwps_info->auth_key));

    wps_hexdump("Key Wrap Key", (u8 *)pwps_info->key_wrap_key, sizeof(pwps_info->key_wrap_key));

    LEAVE();

    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M2 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M2_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_len, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M2);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Registrar Nonce */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID-R */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* Public Key */
    ptr += offset;
    offset = wps_attribute_public_key_prepare(pwps_info, WPS_REGISTRAR, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.auth_type_flag);
    wps_d("M2 Auth type flags %4x", msg_value_short);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.encry_type_flag);
    wps_d("M2 Encry type flags %4x", msg_value_short);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.config_methods);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, &pwps_info->registrar.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.updated_device_password_id);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->registrar.os_version);
    (void)memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Derive Keys */
    wps_derive_kdk(pwps_info);

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M2 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M2_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL, zero_nonce[16], temp_registrar_nonce[16];
    u16 len, wps_frm_body_len, tlv_type, tlv_length, data16;
    u32 data32;

    ENTER();

    (void)memset(zero_nonce, 0, 16);
    (void)memset(temp_registrar_nonce, 0, 16);

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->registrar.version2 > WPS_VERSION)
                {
                    wps_d("(M2) Unknown WPS Version = 0x%x", pwps_info->registrar.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M2)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Registrar_Nonce:
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_UUID_R:
                (void)memcpy(pwps_info->registrar.wps_uuid, data, tlv_length);
                pwps_info->registrar.wps_uuid_length = tlv_length;
                break;
            case SC_Public_Key:
                (void)memcpy(pwps_info->registrar.public_key, data, tlv_length);
                break;
            case SC_Authenticator:
                (void)memcpy(pwps_info->registrar.authenticator, data, tlv_length);
                break;
            case SC_Authentication_Type_Flags:
                (void)memcpy(&data16, data, sizeof(u8));
                pwps_info->registrar.auth_type_flag = ntohs(data16);
                wps_d("Authentication_Type_Flags(M2) = 0x%04x", pwps_info->registrar.auth_type_flag);
                if (!wps_process_authentication_type_flags(pwps_info))
                {
                    wps_d(
                        "Authentication type flag from "
                        "Enrollee dont match with Registrar.\n");
                }
                break;
            case SC_Encryption_Type_Flags:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.encry_type_flag = ntohs(data16);
                wps_d("Encryption_Type_Flags(M2) = 0x%04x", pwps_info->registrar.encry_type_flag);
                if (!wps_process_encryption_type_flags(pwps_info))
                {
                    wps_d(
                        "Encryption type flag from Enrollee"
                        " dont match with Registrar.\n");
                }
                break;
            case SC_Connection_Type_Flags:
                (void)memcpy(&pwps_info->registrar.connection_type_flag, data, tlv_length);
                break;
            case SC_Config_Methods:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.config_methods = ntohs(data16);
                wps_d("Config_Methods(M2) = 0x%04x", pwps_info->registrar.config_methods);
                break;
            case SC_Manufacturer:
                (void)memcpy(pwps_info->registrar.manufacture, data, tlv_length);
                pwps_info->registrar.manufacture_length = tlv_length;
                break;
            case SC_Model_Name:
                (void)memcpy(pwps_info->registrar.model_name, data, tlv_length);
                pwps_info->registrar.model_name_length = tlv_length;
                break;
            case SC_Model_Number:
                (void)memcpy(pwps_info->registrar.model_number, data, tlv_length);
                pwps_info->registrar.model_number_length = tlv_length;
                break;
            case SC_Serial_Number:
                (void)memcpy(pwps_info->registrar.serial_number, data, tlv_length);
                pwps_info->registrar.serial_number_length = tlv_length;
                break;
            case SC_Primary_Device_Type:
                (void)memcpy(pwps_info->registrar.primary_device_type, data, tlv_length);
                break;
            case SC_Device_Name:
                (void)memcpy(pwps_info->registrar.device_name, data, tlv_length);
                pwps_info->registrar.device_name_length = tlv_length;
                break;
            case SC_RF_Band:
                (void)memcpy(&pwps_info->registrar.rf_bands, data, tlv_length);
                break;
            case SC_Association_State:
                (void)memcpy(&pwps_info->registrar.association_state, data, tlv_length);
                break;
            case SC_Configuration_Error:
                (void)memcpy(&pwps_info->registrar.configuration_error, data, tlv_length);
                pwps_info->registrar.configuration_error = ntohs(pwps_info->registrar.configuration_error);
                wps_d("SC_Configuration_Error(M2): %d", pwps_info->registrar.configuration_error);
                break;
            case SC_Device_Password_ID:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.device_password_id = data16;
                break;
            case SC_OS_Version:
                (void)memcpy(&data32, data, tlv_length);
                pwps_info->registrar.os_version = ntohl(data32);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /* Derive Keys */
    wps_derive_kdk(pwps_info);
    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M2D Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M2D_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset         = wps_eap_message_header_prepare(pwps_info, EAP_REQUEST, pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M2D);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Registrar Nonce */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID-R */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.auth_type_flag);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.encry_type_flag);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.config_methods);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, &pwps_info->registrar.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.device_password_id);
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->registrar.os_version);
    (void)memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    peap_wps_frame->length += message_length;

    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    pwps_info->restart_by_M2D = WPS_SET;

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M2D_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data;
    u16 len, tlv_type, tlv_length;
    u32 data32 = 0;
    u16 data16 = 0;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Don't save received M2D frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->registrar.version2 > WPS_VERSION)
                {
                    wps_d("(M2D) Unknown WPS Version = 0x%x", pwps_info->registrar.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M2D)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Registrar_Nonce:
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_UUID_R:
                (void)memcpy(pwps_info->registrar.wps_uuid, data, tlv_length);
                pwps_info->registrar.wps_uuid_length = tlv_length;
                break;
            case SC_Authentication_Type_Flags:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.auth_type_flag = ntohs(data16);
                break;
            case SC_Encryption_Type_Flags:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.encry_type_flag = ntohs(data16);
                break;
            case SC_Connection_Type_Flags:
                (void)memcpy(&pwps_info->registrar.connection_type_flag, data, tlv_length);
                break;
            case SC_Config_Methods:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.config_methods = ntohs(data16);
                break;
            case SC_Manufacturer:
                (void)memcpy(pwps_info->registrar.manufacture, data, tlv_length);
                pwps_info->registrar.manufacture_length = tlv_length;
                break;
            case SC_Model_Name:
                (void)memcpy(pwps_info->registrar.model_name, data, tlv_length);
                pwps_info->registrar.model_name_length = tlv_length;
                break;
            case SC_Model_Number:
                (void)memcpy(pwps_info->registrar.model_number, data, tlv_length);
                pwps_info->registrar.model_number_length = tlv_length;
                break;
            case SC_Serial_Number:
                (void)memcpy(pwps_info->registrar.serial_number, data, tlv_length);
                pwps_info->registrar.serial_number_length = tlv_length;
                break;
            case SC_Primary_Device_Type:
                (void)memcpy(pwps_info->registrar.primary_device_type, data, tlv_length);
                break;
            case SC_Device_Name:
                (void)memcpy(pwps_info->registrar.device_name, data, tlv_length);
                pwps_info->registrar.device_name_length = tlv_length;
                break;
            case SC_RF_Band:
                (void)memcpy(&pwps_info->registrar.rf_bands, data, tlv_length);
                break;
            case SC_Association_State:
                (void)memcpy(&pwps_info->registrar.association_state, data, tlv_length);
                break;
            case SC_Configuration_Error:
                (void)memcpy(&pwps_info->registrar.configuration_error, data, tlv_length);
                pwps_info->registrar.configuration_error = ntohs(pwps_info->registrar.configuration_error);
                wps_d("SC_Configuration_Error(M2D): %d", pwps_info->registrar.configuration_error);
                break;
            case SC_Device_Password_ID:
                (void)memcpy(&data16, data, tlv_length);
                pwps_info->registrar.device_password_id = data16;
                break;
            case SC_OS_Version:
                (void)memcpy(&data32, data, tlv_length);
                pwps_info->registrar.os_version = ntohl(data32);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    pwps_info->restart_by_M2D = WPS_SET;

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M3 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M3_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 RawPSK[32] = {0};
    u8 HASH[32]   = {0};
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    /* Generate PSK1 */
    (void)memset(PSK1, 0, sizeof(PSK1));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, pwps_info->PIN, pwps_info->PINLen / 2, RawPSK,
                    SHA256_DIGEST_SIZE);

    (void)memcpy(PSK1, RawPSK, PSK_LEN); /* Only 16 Bytes (128 bits) needed */
    wps_hexdump("PSK1", (u8 *)PSK1, sizeof(PSK1));

    /* Generate PSK2 */
    (void)memset(PSK2, 0, sizeof(PSK2));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, &pwps_info->PIN[pwps_info->PINLen / 2], pwps_info->PINLen / 2,
                    RawPSK, SHA256_DIGEST_SIZE);

    (void)memcpy(PSK2, RawPSK, PSK_LEN); /* Only 16 Bytes (128 bits) needed */
    wps_hexdump("PSK2", (u8 *)PSK2, sizeof(PSK2));

    wps_hexdump("ES1", (u8 *)pwps_info->enrollee.e_s1, sizeof(pwps_info->enrollee.e_s1));

    /* Get E-Hash1 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->enrollee.e_s1, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);
    (void)memcpy(pwps_info->enrollee.e_hash1, HASH, 32);
    wps_hexdump("E-HASH1", (u8 *)pwps_info->enrollee.e_hash1, sizeof(pwps_info->enrollee.e_hash1));

    /* Get E-Hash2 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->enrollee.e_s2, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    (void)memcpy(pwps_info->enrollee.e_hash2, HASH, 32);
    wps_hexdump("E-HASH2", (u8 *)pwps_info->enrollee.e_hash2, sizeof(pwps_info->enrollee.e_hash2));

    message_len    = 0;
    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);
    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M3);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* E-Hash1 */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_E_Hash1);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.e_hash1, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* E-Hash2 */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_E_Hash2);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.e_hash2, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M3 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M3_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->enrollee.version2 > WPS_VERSION)
                {
                    wps_d("(M3) Unknown WPS Version = 0x%x", pwps_info->enrollee.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M3)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Registrar_Nonce:
                if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M3_process: SC_Registrar_Nonce Fail!!");
                    return WPS_STATUS_FAIL;
                }
                wps_d("@M3_process: SC_Registrar_Nonce OK");
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_E_Hash1:
                (void)memcpy(pwps_info->enrollee.e_hash1, data, tlv_length);
                wps_hexdump("E-HASH1 Received", (u8 *)pwps_info->enrollee.e_hash1, tlv_length);
                break;
            case SC_E_Hash2:
                (void)memcpy(pwps_info->enrollee.e_hash2, data, tlv_length);
                wps_hexdump("E-HASH2 Received", (u8 *)pwps_info->enrollee.e_hash2, tlv_length);
                break;
            case SC_Authenticator:
                (void)memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M4 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M4_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 RawPSK[32];
    u8 HASH[32];
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    wps_hexdump("our PIN", (u8 *)pwps_info->PIN, pwps_info->PINLen);

    /* Generate PSK1 */
    (void)memset(PSK1, 0, sizeof(PSK1));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, pwps_info->PIN, pwps_info->PINLen / 2, RawPSK,
                    SHA256_DIGEST_SIZE);

    (void)memcpy(PSK1, RawPSK, 16); /* Only 16 Bytes (128 bits) needed */
    wps_hexdump("PSK1", (u8 *)PSK1, sizeof(PSK1));

    /* Generate PSK2 */
    (void)memset(PSK2, 0, sizeof(PSK2));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, &pwps_info->PIN[pwps_info->PINLen / 2], pwps_info->PINLen / 2,
                    RawPSK, SHA256_DIGEST_SIZE);

    (void)memcpy(PSK2, RawPSK, sizeof(PSK2)); /* Only 16 Bytes (128 bits) needed */
    wps_hexdump("PSK2", (u8 *)PSK2, sizeof(PSK2));

    /* Get E-Hash1 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->registrar.r_s1, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    (void)memcpy(pwps_info->registrar.r_hash1, HASH, 32);
    wps_hexdump("R-HASH1", (u8 *)pwps_info->registrar.r_hash1, sizeof(pwps_info->registrar.r_hash1));

    /* Get E-Hash2 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->registrar.r_s2, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    (void)memcpy(pwps_info->registrar.r_hash2, HASH, 32);
    wps_hexdump("R-HASH2", (u8 *)pwps_info->registrar.r_hash2, sizeof(pwps_info->registrar.r_hash2));

    message_len    = 0;
    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M4);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* R-Hash1 */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_R_Hash1);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.r_hash1, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* R-Hash2 */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_R_Hash2);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.r_hash2, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;

    for (i = 0; i < 16; i++)
    {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    (void)memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* R-SNonce1 */
    (void)memset(EncryData, 0x00, sizeof(EncryData));
    pEncry        = EncryData;
    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_R_SNonce1);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->registrar.r_s1, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    (void)memset(KWA, 0, sizeof(KWA));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    nxp_aes_wrap(EncryData, pEncry - EncryData, EncryAesOutput, pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
    (void)memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M4 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M4_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, tlv_type, tlv_length, wps_frm_body_len, offset;
    u8 HASH[32] = {0};

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->registrar.version2 > WPS_VERSION)
                {
                    wps_d("(M4) Unknown WPS Version = 0x%x", pwps_info->registrar.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M4)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M4_process: SC_Enrollee_Nonce Fail!!");
                    return WPS_STATUS_FAIL;
                }
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_R_Hash1:
                (void)memcpy(pwps_info->registrar.r_hash1, data, tlv_length);
                wps_hexdump("R-HASH1 Received", (u8 *)pwps_info->registrar.r_hash1, tlv_length);
                break;
            case SC_R_Hash2:
                (void)memcpy(pwps_info->registrar.r_hash2, data, tlv_length);
                wps_hexdump("R-HASH2 Received", (u8 *)pwps_info->registrar.r_hash2, tlv_length);
                break;
            case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                (void)memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                (void)memcpy(pwps_info->registrar.encrypted_data, data + 16, pwps_info->registrar.encrypted_data_len);
                PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)(pwps_info->registrar.wrap_raw_data);
                (void)memset(pwps_info->registrar.wrap_raw_data, 0x00, sizeof(pwps_info->registrar.wrap_raw_data));
                nxp_aes_unwrap(pwps_info->registrar.encrypted_data, pwps_info->registrar.encrypted_data_len,
                               pwps_info->registrar.wrap_raw_data, pwps_info->key_wrap_key, 16,
                               pwps_info->registrar.IV);

                while (((u8 *)pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16))
                {
                    estype      = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata      = (u8 *)pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype)
                    {
                        case SC_R_SNonce1:
                            (void)memcpy(pwps_info->registrar.r_s1, esdata, pes->length);
                            break;
                        case SC_Key_Wrap_Authenticator:
                            (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
                            break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes  = (PTLV_DATA_HEADER)((u8 *)pes + elen);
                } /* while */

                break;
            }
            case SC_Authenticator:
                (void)memcpy(pwps_info->registrar.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /* Get R-Hash1 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->registrar.r_s1, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK1, 16);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    wps_hexdump("R-HASH1 computed", (u8 *)HASH, 32);
    if (memcmp(pwps_info->registrar.r_hash1, HASH, 32))
    {
        wps_d("@M4_process: r_hash1 mis-match!!");
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M5 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M5_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M5);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.nonce, 0x10);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++)
    {
        pwps_info->enrollee.IV[i] = rand() % 10;
    }
    if (pwps_info->enrollee.IV[0] == 0)
        pwps_info->enrollee.IV[0] += 1;
    (void)memcpy(ptr, pwps_info->enrollee.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* E-SNonce1 */
    (void)memset(EncryData, 0x00, sizeof(EncryData));
    pEncry        = EncryData;
    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_E_SNonce1);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.e_s1, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    (void)memset(KWA, 0, sizeof(KWA));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    nxp_aes_wrap(EncryData, pEncry - EncryData, EncryAesOutput, pwps_info->key_wrap_key, 16, pwps_info->enrollee.IV);

    (void)memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M5 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M5_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length, offset;
    u8 HASH[32];

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->enrollee.version2 > WPS_VERSION)
                {
                    wps_d("(M5) Unknown WPS Version = 0x%x", pwps_info->enrollee.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M5)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Registrar_Nonce:
                if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M5_process: SC_Registrar_Nonce Fail!!");
                    return WPS_STATUS_FAIL;
                }
                wps_d("@M5_process: SC_Registrar_Nonce OK");
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                (void)memcpy(pwps_info->enrollee.IV, data, 16);
                pwps_info->enrollee.encrypted_data_len = tlv_length - 16;
                (void)memcpy(pwps_info->enrollee.encrypted_data, data + 16, pwps_info->enrollee.encrypted_data_len);

                PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)(pwps_info->enrollee.wrap_raw_data);
                (void)memset(pwps_info->enrollee.wrap_raw_data, 0x00, sizeof(pwps_info->enrollee.wrap_raw_data));
                nxp_aes_unwrap(pwps_info->enrollee.encrypted_data, pwps_info->enrollee.encrypted_data_len,
                               pwps_info->enrollee.wrap_raw_data, pwps_info->key_wrap_key, 16, pwps_info->enrollee.IV);

                while (((u8 *)pes - pwps_info->enrollee.wrap_raw_data) < (pwps_info->enrollee.encrypted_data_len - 16))
                {
                    estype      = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata      = (u8 *)pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype)
                    {
                        case SC_E_SNonce1:
                            (void)memcpy(pwps_info->enrollee.e_s1, esdata, pes->length);
                            break;
                        case SC_Key_Wrap_Authenticator:
                            (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
                            break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes  = (PTLV_DATA_HEADER)((u8 *)pes + elen);
                }
                break;
            }
            case SC_Authenticator:
                (void)memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /* Get E-Hash1 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->enrollee.e_s1, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    wps_hexdump("E-HASH1 computed", (u8 *)HASH, 32);
    if (memcmp(pwps_info->enrollee.e_hash1, HASH, 32))
    {
        wps_d("@M5_process: e_hash1 mis-match!!");
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M6 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M6_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M6);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++)
    {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    (void)memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* R-SNonce2 */
    (void)memset(EncryData, 0x00, sizeof(EncryData));
    pEncry        = EncryData;
    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = SC_R_SNonce2;
    ptlvE->type   = htons(ptlvE->type);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->registrar.r_s2, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    (void)memset(KWA, 0, sizeof(KWA));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    nxp_aes_wrap(EncryData, pEncry - EncryData, EncryAesOutput, pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);

    (void)memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M6 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M6_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, tlv_type, tlv_length, wps_frm_body_len, offset;
    u8 HASH[32] = {0};

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->registrar.version2 > WPS_VERSION)
                {
                    wps_d("(M2) Unknown WPS Version = 0x%x", pwps_info->registrar.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M6)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M6_process: SC_Enrollee_Nonce Fail!!");
                    return WPS_STATUS_FAIL;
                }
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                (void)memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                (void)memcpy(pwps_info->registrar.encrypted_data, data + 16, pwps_info->registrar.encrypted_data_len);

                PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)(pwps_info->registrar.wrap_raw_data);
                (void)memset(pwps_info->registrar.wrap_raw_data, 0x00, sizeof(pwps_info->registrar.wrap_raw_data));
                nxp_aes_unwrap(pwps_info->registrar.encrypted_data, pwps_info->registrar.encrypted_data_len,
                               pwps_info->registrar.wrap_raw_data, pwps_info->key_wrap_key, 16,
                               pwps_info->registrar.IV);

                while (((u8 *)pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16))
                {
                    estype      = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata      = (u8 *)pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype)
                    {
                        case SC_R_SNonce2:
                            (void)memcpy(pwps_info->registrar.r_s2, esdata, pes->length);
                            break;
                        case SC_Key_Wrap_Authenticator:
                            (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
                            break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes  = (PTLV_DATA_HEADER)((u8 *)pes + elen);
                }
                break;
            }
            case SC_Authenticator:
                (void)memcpy(pwps_info->registrar.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /* Get R-Hash2 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->registrar.r_s2, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK2, 16);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    wps_hexdump("R-HASH2 computed", (u8 *)HASH, 32);
    if (memcmp(pwps_info->registrar.r_hash2, HASH, 32))
    {
        wps_d("@M6_process: r_hash1 mis-match!!");
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

#if 0
int wps_add_ap_settings_to_registrar(PWPS_INFO pwps_info, u8 *pEncry)
{
    int ap_setting_len = 0;
    u16 msg_value_short;
    PTLV_DATA_HEADER ptlvC;

    /* SSID */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_SSID);
    ptlvC->length = pwps_info->enrollee.cred_data[0].ssid_length;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.cred_data[0].ssid, ptlvC->length);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* AP's MAC Address */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_MAC_Address);
    ptlvC->length = 6;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.mac_address, 6);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Authentication Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Authentication_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.cred_data[0].auth_type);
    (void)memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Encryption Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Encryption_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.cred_data[0].encry_type);
    (void)memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key Index */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, &pwps_info->enrollee.cred_data[0].network_key_index, 1);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key);
    ptlvC->length = pwps_info->enrollee.cred_data[0].network_key_len;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.cred_data[0].network_key,
           ptlvC->length);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    wps_d("AP Setting len: %d", ap_setting_len);
    return ap_setting_len;
}
#endif

/**
 *  @brief  Prepare and Send WPS M7 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M7_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret, enc_setting_len = 0;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M7);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Encrypted_Settings);
    ptlv->length = 0x0;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++)
    {
        pwps_info->enrollee.IV[i] = rand() % 10;
    }
    if (pwps_info->enrollee.IV[0] == 0)
        pwps_info->enrollee.IV[0] += 1;
    (void)memcpy(ptr, pwps_info->enrollee.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;
    ptlv->length += WPS_NONCE_SIZE;

    /* E-SNonce2 */
    (void)memset(EncryData, 0x00, sizeof(EncryData));
    pEncry        = EncryData;
    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_E_SNonce2);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.e_s2, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

#if 0
    if (wps_s->bss_type == BSS_TYPE_UAP) {
        /* Report Current AP settings to Registrar */
        pEncry += wps_add_ap_settings_to_registrar(pwps_info, pEncry);
    }
#endif

    /* Key Wrap Authenticator */
    (void)memset(KWA, 0, sizeof(KWA));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, EncryData, pEncry - EncryData, KWA, SHA256_DIGEST_SIZE);

    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));

    wps_hexdump("M7_preEncry", (u8 *)EncryData, pEncry - EncryData);
    enc_setting_len = nxp_aes_wrap_ext(EncryData, pEncry - EncryData, EncryAesOutput, pwps_info->key_wrap_key, 16,
                                       pwps_info->enrollee.IV);
    if (enc_setting_len != 0)
    {
        (void)memcpy(ptr, EncryAesOutput, enc_setting_len);
    }
    ptr += enc_setting_len;
    ptlv->length += enc_setting_len;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* XXX: Add the optional "SETTING DELAY TIME" here if needed */

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS M7 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M7_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length, offset;
    u8 HASH[32];

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->enrollee.version2 > WPS_VERSION)
                {
                    wps_d("(M7) Unknown WPS Version = 0x%x", pwps_info->enrollee.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_M7)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Registrar_Nonce:
                if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M7_process: SC_Registrar_Nonce Fail!!");
                    return WPS_STATUS_FAIL;
                }
                wps_d("@M7_process: SC_Registrar_Nonce OK");
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype, tmp_type;
                u8 *esdata;
                CREDENTIAL_DATA *pCred = (CREDENTIAL_DATA *)&pwps_info->enrollee.cred_data[0];

                (void)memcpy(pwps_info->enrollee.IV, data, 16);
                pwps_info->enrollee.encrypted_data_len = tlv_length - 16;
                (void)memcpy(pwps_info->enrollee.encrypted_data, data + 16, pwps_info->enrollee.encrypted_data_len);
                PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)(pwps_info->enrollee.wrap_raw_data);
                (void)memset(pwps_info->enrollee.wrap_raw_data, 0x00, sizeof(pwps_info->enrollee.wrap_raw_data));
                nxp_aes_unwrap(pwps_info->enrollee.encrypted_data, pwps_info->enrollee.encrypted_data_len,
                               pwps_info->enrollee.wrap_raw_data, pwps_info->key_wrap_key, 16, pwps_info->enrollee.IV);

                while (((u8 *)pes - pwps_info->enrollee.wrap_raw_data) < (pwps_info->enrollee.encrypted_data_len - 16))
                {
                    estype      = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata      = (u8 *)pes;
                    esdata += SZ_TLV_HEADER;

                    switch (estype)
                    {
                        case SC_E_SNonce2:
                            (void)memcpy(pwps_info->enrollee.e_s2, esdata, pes->length);
                            break;
                        case SC_Key_Wrap_Authenticator:
                            (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
                            break;
                        case SC_SSID:
                            wps_d("SC_SSID");
                            pCred->ssid_length = MIN(pes->length, sizeof(pCred->ssid));
                            (void)memcpy(pCred->ssid, esdata, pCred->ssid_length);
                            wps_d("SSID : %s", pCred->ssid);
                            break;

                        case SC_MAC_Address:
                            wps_d("SC_MAC_Address");
                            (void)memcpy(pCred->mac_address, esdata, ETH_ALEN);
                            break;

                        case SC_Authentication_Type:
                            wps_d("SC_Authentication_Type");
                            (void)memcpy((u8 *)&tmp_type, esdata, sizeof(u16));
                            pCred->auth_type = ntohs(tmp_type);
                            wps_d("Authentication_Type(M7) = 0x%04x", pCred->auth_type);
                            break;

                        case SC_Encryption_Type:
                            wps_d("SC_Encryption_Type");
                            (void)memcpy((u8 *)&tmp_type, esdata, sizeof(u16));
                            pCred->encry_type = ntohs(tmp_type);
                            wps_d("Encryption_Type(M7) = 0x%04x", pCred->encry_type);
                            break;

                        case SC_Network_Key:
                            wps_hexdump("SC_Network_Key", (u8 *)esdata, pes->length);
                            (void)memcpy(pCred->network_key, esdata, pes->length);
                            pCred->network_key_len = pes->length;
                            break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes  = (PTLV_DATA_HEADER)((u8 *)pes + elen);
                }
                break;
            }
            case SC_Authenticator:
                (void)memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    /* Get E-Hash2 */
    (void)memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    (void)memcpy(HashArgu, pwps_info->enrollee.e_s2, 16);
    offset += 16;
    (void)memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    (void)memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, HashArgu, offset, HASH, SHA256_DIGEST_SIZE);

    wps_hexdump("E-HASH2 computed", (u8 *)HASH, 32);

    if (memcmp(pwps_info->enrollee.e_hash2, HASH, 32))
    {
        wps_d("@M7_process: e_hash2 mis-match!!");
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }
    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS M8 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M8_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE = NULL, ptlvC;
    u16 msg_value_short, offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    u8 datalength = 0;
    int i, ret, enc_setting_len = 0;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);
    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M8);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv       = (PTLV_DATA_HEADER)ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++)
    {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    (void)memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* Credential */
    (void)memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;

    if (wps_s->bss_type == BSS_TYPE_UAP)
    {
        ptlvE         = (PTLV_DATA_HEADER)pEncry;
        ptlvE->type   = htons(SC_Credential);
        ptlvE->length = 0;
        pEncry += SZ_TLV_HEADER;
    }

    /* ----- Credential Start ----- */
    /* Network Index */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_Network_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    *pEncry = 0x1;
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* SSID */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_SSID);
    ptlvC->length = pwps_info->registrar.cred_data[0].ssid_length;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->registrar.cred_data[0].ssid, ptlvC->length);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Authentication Type */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_Authentication_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    /* For legacy enrollee, don't use the new mixed mode auth type */
    if (!pwps_info->enrollee.version2 && (pwps_info->registrar.cred_data[0].auth_type == AUTHENTICATION_TYPE_WPA_MIXED))
    {
        msg_value_short = htons(AUTHENTICATION_TYPE_WPA2PSK);
    }
    else
    {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].auth_type);
    }
    (void)memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Encryption Type */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_Encryption_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    if (pwps_info->enrollee.version2)
    {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].encry_type);
    }
    else if (pwps_info->registrar.cred_data[0].encry_type == (ENCRYPTION_TYPE_AES | ENCRYPTION_TYPE_TKIP))
    {
        if (pwps_info->enrollee.encry_type_flag & ENCRYPTION_TYPE_AES)
            msg_value_short = htons(ENCRYPTION_TYPE_AES);
        else if (pwps_info->enrollee.encry_type_flag & ENCRYPTION_TYPE_TKIP)
            msg_value_short = htons(ENCRYPTION_TYPE_TKIP);
        else
        {
            wps_d(
                "wps_eap_M8_frame_prepare: No suitable "
                "Encryption type supported.\n");
        }
    }
    else
    {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].encry_type);
    }
    (void)memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key Index */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_Network_Key_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, &pwps_info->registrar.cred_data[0].network_key_index, 1);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_Network_Key);
    ptlvC->length = pwps_info->registrar.cred_data[0].network_key_len;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->registrar.cred_data[0].network_key, ptlvC->length);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* MAC Address */
    ptlvC         = (PTLV_DATA_HEADER)pEncry;
    ptlvC->type   = htons(SC_MAC_Address);
    ptlvC->length = 6;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, pwps_info->enrollee.mac_address, 6);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    if (wps_s->bss_type == BSS_TYPE_UAP)
    {
        ptlvE->length = htons(enc_setting_len);
    }
    /* ----- Credential End ----- */

    /* Key Wrap Authenticator */
    (void)memset(KWA, 0, sizeof(KWA));
    nxp_hmac_sha256(pwps_info->auth_key, SZ_AUTH_KEY, EncryData, pEncry - EncryData, KWA, SHA256_DIGEST_SIZE);

    ptlvE         = (PTLV_DATA_HEADER)pEncry;
    ptlvE->type   = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = SZ_KWA;
    pEncry += SZ_TLV_HEADER;
    (void)memcpy(pEncry, KWA, SZ_KWA);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    wps_d("M8 : pEncry-EncryData = 0x%x", pEncry - EncryData);
    wps_hexdump("M8_prepare Key Wrap Key", (u8 *)pwps_info->key_wrap_key, sizeof(pwps_info->key_wrap_key));
    (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    datalength = pEncry - EncryData;

    wps_d("datalength(pEncry-EncryData) = %d", datalength);

    if (datalength % 32 == 0)
    {
        wps_hexdump("M8_preEncry", (u8 *)EncryData, datalength);
        (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
        nxp_aes_wrap(EncryData, datalength, EncryAesOutput, pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);

        (void)memcpy(ptr, EncryAesOutput, datalength + 16);
        ptr += datalength + 16;
        ptlv->length = WPS_NONCE_SIZE + datalength + 16;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptlv->length = htons(ptlv->length);
    }
    else
    {
        if (datalength % 16 == 0 && datalength % 32 != 0)
            datalength = datalength - datalength % 32 + 32;
        else if (datalength % 16 != 0)
            datalength = datalength - datalength % 16 + 16;

        /* Padding the value of # of paddings */
        for (i = 0; i < datalength - (pEncry - EncryData); i++)
        {
            *(EncryData + (pEncry - EncryData) + i) = datalength - (pEncry - EncryData);
        }

        wps_hexdump("M8_preEncry", (u8 *)EncryData, datalength);
        (void)memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
        nxp_aes_wrap(EncryData, datalength, EncryAesOutput, pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);

        (void)memcpy(ptr, EncryAesOutput, datalength);
        ptr += datalength;
        ptlv->length = WPS_NONCE_SIZE + datalength;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptlv->length = htons(ptlv->length);
    }

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Authenticator */
    message_len = message_length;
    offset      = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset                 = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)offset);

    wps_write_credentials(pwps_info);

#if 0
    if (IS_DISCOVERY_REGISTRAR(pwps_info)) {
        wfd_update_persistent_record(pwps_info);
    }
#endif

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

static inline int wps_get_sizeof_ssid(u8 *ssid, u8 ssid_len)
{
    u16 ssid_length = 0, i = 0;
    for (i = 0; i < ssid_len; i++)
    {
        if (ssid[i] != 0)
            ssid_length++;
        else
            return ssid_length;
    }
    return ssid_length;
}

int wps_process_ap_settings_from_registrar(PWPS_INFO pwps_info, u8 *ptr, u32 len)
{
    u16 estype, tmp_type;
    u8 *esdata;
    int ret                = WPS_STATUS_SUCCESS;
    CREDENTIAL_DATA *pCred = (CREDENTIAL_DATA *)&pwps_info->registrar.cred_data[0];
    ENTER();

    wps_hexdump("M8_AP_Settings", ptr, len);
    /* We received AP settings from Registrar. */
    pwps_info->read_ap_config_only = WPS_CANCEL;

    wps_d(
        "Resetting AP config read only variable. "
        "AP configuration would be modified!");

    while (len > 0)
    {
        PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)ptr;
        estype               = ntohs(pes->type);
        pes->length          = ntohs(pes->length);
        esdata               = (u8 *)pes;
        esdata += SZ_TLV_HEADER;

        switch (estype)
        {
            case SC_Key_Wrap_Authenticator:
                wps_d("SC_Key_Wrap_Authenticator");
                (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
                break;
            case SC_Network_Index:
                wps_d("SC_Network_Index");
                (void)memcpy(&pCred->network_index, esdata, pes->length);
                break;
            case SC_SSID:
                wps_d("SC_SSID");
                pCred->ssid_length = MIN(pes->length, wps_get_sizeof_ssid(esdata, pes->length));
                (void)memcpy(pCred->ssid, esdata, pCred->ssid_length);
                wps_d("SSID length: %d", pCred->ssid_length);
                wps_d("SSID : %s", pCred->ssid);
                break;
            case SC_Authentication_Type:
                wps_d("SC_Authentication_Type");
                (void)memcpy((u8 *)&tmp_type, esdata, sizeof(u16));
                pCred->auth_type = ntohs(tmp_type);
                wps_d("Authentication_Type(M8) = 0x%04x", pCred->auth_type);
                break;
            case SC_Encryption_Type:
                wps_d("SC_Encryption_Type");
                (void)memcpy((u8 *)&tmp_type, esdata, sizeof(u16));
                pCred->auth_type = ntohs(tmp_type);
                pCred->encry_type = ntohs(pCred->encry_type);
                wps_d("Encryption_Type(M8) = 0x%04x", pCred->encry_type);
                break;
            case SC_Network_Key_Index:
                wps_d("SC_Network_Key_Index");
                (void)memcpy(&pCred->network_key_index, esdata, pes->length);
                wps_d("Network Key Index = %d", pCred->network_key_index);
                break;
            case SC_Network_Key:
                wps_d("SC_Network_Key");
                wps_hexdump("SC_Network_Key", (u8 *)esdata, pes->length);
                (void)memcpy(pCred->network_key, esdata, pes->length);
                pCred->network_key_len = pes->length;
                break;
            case SC_MAC_Address:
                wps_d("SC_MAC_Address");
                (void)memcpy(pCred->mac_address, esdata, pes->length);
                break;
            default:
                wps_d("Unknown msg_Type = 0x%x", pes->type);
                break;
        }
        len -= pes->length + SZ_TLV_HEADER;
        ptr += pes->length + SZ_TLV_HEADER;
    }

    if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0)
    {
        switch (pCred->encry_type)
        {
            case ENCRYPTION_TYPE_WEP:
                wps_d("Invalid WSC2.0 credential. Encryption WEP!");
                pwps_info->read_ap_config_only = WPS_SET;
                ret                            = WPS_STATUS_FAIL;
                break;
            case ENCRYPTION_TYPE_TKIP:
                if (pCred->auth_type == AUTHENTICATION_TYPE_WPAPSK)
                {
                    wps_d(
                        "WPA-TKIP Encryption received. "
                        "Modifying to WPA-WPA2 mixed");
                    pCred->auth_type = AUTHENTICATION_TYPE_WPA_MIXED;
                    ret              = WPS_STATUS_SUCCESS;
                }
                else
                {
                    pwps_info->read_ap_config_only = WPS_SET;
                    ret                            = WPS_STATUS_FAIL;
                }
                break;
            default:
                break;
        }
    }
    wps_d("calling change ==== auth:0x%x", pwps_info->registrar.cred_data[0].auth_type);
    LEAVE();
    return ret;
}

/**
 *  @brief  Process received WPS M8 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_M8_frame_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;
    u16 data16;
    int cred_ind, num_invalid_cred = 0;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER)buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02)
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER + SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    }
    else
    {
        ptlv             = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body     = (u8 *)ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump("ptlv", (u8 *)ptlv, size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                wps_d("SC_Version");
                (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                if (pwps_info->registrar.version2 > WPS_VERSION)
                {
                    wps_d("(M8) Unknown WPS Version = 0x%x", pwps_info->registrar.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("SC_Message_Type = 0x%x", *data);
                if (*data != WPS_M8)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                wps_d("SC_Enrollee_Nonce");
                if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0)
                {
                    wps_d("@M8_process: SC_Enrollee_Nonce Fail");
                    return WPS_STATUS_FAIL;
                }
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype, pes_length;
                u8 *esdata;
                int aes_len;

                num_cred = 0;
                (void)memset(pwps_info->registrar.cred_data, 0x00, MAX_NUM_CRDENTIAL * sizeof(CREDENTIAL_DATA));

                wps_d("SC_Encrypted_Settings");
                (void)memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                (void)memcpy(pwps_info->registrar.encrypted_data, data + 16, pwps_info->registrar.encrypted_data_len);
                wps_hexdump("encrypted_data", (u8 *)pwps_info->registrar.encrypted_data,
                            pwps_info->registrar.encrypted_data_len);

                PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER)(pwps_info->registrar.wrap_raw_data);
                (void)memset(pwps_info->registrar.wrap_raw_data, 0x00, sizeof(pwps_info->registrar.wrap_raw_data));

                wps_hexdump("M8_process Key Wrap Key", (u8 *)pwps_info->key_wrap_key, sizeof(pwps_info->key_wrap_key));

                wps_hexdump("M8_Decry i/p", (u8 *)pwps_info->registrar.encrypted_data,
                            pwps_info->registrar.encrypted_data_len);
                aes_len = nxp_aes_unwrap_ext(
                    pwps_info->registrar.encrypted_data, pwps_info->registrar.encrypted_data_len,
                    pwps_info->registrar.wrap_raw_data, pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
                if (aes_len < 0)
                {
                    wps_d("SC_Encrypted_Settings");
                    return WPS_STATUS_FAIL;
                }
                pwps_info->registrar.encrypted_data_len = (u16)aes_len;

                wps_hexdump("M8_process Wrap Raw Data", (u8 *)pwps_info->registrar.wrap_raw_data,
                            pwps_info->registrar.encrypted_data_len);
                while (((u8 *)pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16))
                {
                    estype     = ntohs(pes->type);
                    pes_length = ntohs(pes->length);
                    esdata     = (u8 *)pes;
                    esdata += SZ_TLV_HEADER;

                    switch (estype)
                    {
                        case SC_Key_Wrap_Authenticator:
                            wps_d("SC_Key_Wrap_Authenticator");
                            (void)memcpy(pwps_info->key_wrap_authenticator, esdata, pes_length);
                            break;
                        case SC_Credential:
                        {
                            PTLV_DATA_HEADER pcre = (PTLV_DATA_HEADER)(esdata);
                            u16 clen, pcre_length;
                            int cretype = 0;
                            u8 *credata;
                            CREDENTIAL_DATA *pCred;

                            wps_d("SC_Credential");

                            num_cred++;
                            wps_d(
                                "Num of "
                                "SC_Credential received = %d",
                                num_cred);
                            if (num_cred >= MAX_NUM_CRDENTIAL)
                                num_cred = MAX_NUM_CRDENTIAL;
                            wps_d(
                                "Num of "
                                "SC_Credential saved = %d",
                                num_cred);

                            pCred = (CREDENTIAL_DATA *)&pwps_info->registrar.cred_data[num_cred - 1];

                            while (((u8 *)pcre - esdata) < pes_length)
                            {
                                cretype     = ntohs(pcre->type);
                                pcre_length = ntohs(pcre->length);
                                credata     = (u8 *)pcre;
                                credata += SZ_TLV_HEADER;

                                switch (cretype)
                                {
                                    case SC_Network_Index:
                                        wps_d("SC_Network_Index");
                                        (void)memcpy(&pCred->network_index, credata, pcre_length);
                                        break;
                                    case SC_SSID:
                                        wps_d("SC_SSID");
                                        pCred->ssid_length = MIN(pcre_length, sizeof(pCred->ssid));
                                        (void)memcpy(pCred->ssid, credata, pCred->ssid_length);
                                        wps_d("SSID : %s", pCred->ssid);
                                        wps_d("SSID length: %d", pCred->ssid_length);
                                        break;
                                    case SC_Authentication_Type:
                                        wps_d("SC_Authentication_Type");
                                        (void)memcpy(&data16, credata, pcre_length);
                                        pCred->auth_type = ntohs(data16);
                                        wps_d("Authentication_Type(M8) = 0x%04x", pCred->auth_type);
                                        break;
                                    case SC_Encryption_Type:
                                        wps_d("SC_Encryption_Type");
                                        (void)memcpy(&data16, credata, pcre_length);
                                        pCred->encry_type = ntohs(data16);
                                        wps_d("Encryption_Type(M8) = 0x%04x", pCred->encry_type);
                                        break;
                                    case SC_Network_Key_Index:
                                        wps_d("SC_Network_Key_Index");
                                        (void)memcpy(&pCred->network_key_index, credata, pcre_length);
                                        break;
                                    case SC_WEP_Transmit_Key:
                                        wps_d("SC_WEP_Transmit_Key");
                                        (void)memcpy(&pCred->wep_tx_key_index, credata, pcre_length);
                                        break;
                                    case SC_Network_Key:
                                        wps_d("SC_Network_Key");
                                        wps_hexdump("SC_Network_Key", (u8 *)credata, pcre_length);
                                        (void)memcpy(pCred->network_key, credata, pcre_length);
                                        pCred->network_key_len = pcre_length;
                                        break;
                                    case SC_MAC_Address:
                                        wps_d("SC_MAC_Address");
                                        (void)memcpy(pCred->mac_address, credata, pcre_length);
                                        break;
                                    case SC_RF_Band:
                                        wps_d("SC_RF_Band");
                                        (void)memcpy(&pCred->rf_bands, credata, pcre_length);
                                        break;
                                }
                                clen = pcre_length + SZ_TLV_HEADER;
                                pcre = (PTLV_DATA_HEADER)((u8 *)pcre + clen);
                            } /* while */
                        }
                        break;
                    }
                    elen = pes_length + SZ_TLV_HEADER;
                    pes  = (PTLV_DATA_HEADER)((u8 *)pes + elen);
                }
                if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0)
                {
                    for (cred_ind = 0; cred_ind < num_cred; cred_ind++)
                    {
                        CREDENTIAL_DATA *pCred;
                        pCred = (CREDENTIAL_DATA *)&pwps_info->registrar.cred_data[cred_ind];
                        if (pCred->encry_type == ENCRYPTION_TYPE_WEP || pCred->encry_type == ENCRYPTION_TYPE_TKIP)
                        {
                            wps_d(
                                "@M8_process: "
                                "Invalid WSC2.0 credential %d\n",
                                pCred->encry_type);
                            num_invalid_cred++;
                        }
                    }

                    if (num_invalid_cred == num_cred)
                    {
                        pwps_info->invalid_credential = WPS_SET;
                        wps_d(
                            "@M8_process: No "
                            "valid wsc2 credentials found\n");
                        wps_d(
                            "No valid WPS 2.0 "
                            "credentials found!");

                        return WPS_STATUS_FAIL;
                    }
                }
                break;
            }
            case SC_Authenticator:
                (void)memcpy(pwps_info->registrar.authenticator, data, tlv_length);
                break;
            default:
                wps_d("Unknown message_Type = 0x%x", tlv_type);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len) != WPS_STATUS_SUCCESS)
    {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    (void)memcpy(&pwps_info->last_tx_message, &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS Done Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_done_message_prepare(PWPS_INFO pwps_info)
{
    int offset;
    int ret;
    u8 *ptr            = pwps_info->buffer;
    u16 message_length = 0;
    WPS_DATA *wps_s    = (WPS_DATA *)&wps_global;
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    offset         = wps_message_common_attribute_prepare(pwps_info, pwps_info->peer_id,
                                                  (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                                  WPS_Done, WPS_DONE);

    message_length += offset;
    ptr += offset;

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() */
    /* Update EAP header len */
    peap_wps_frame->length = htons(message_length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS Done Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_done_message_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len, ptlv_type, ptlv_len;

    ENTER();

    size       = ntohs(size);
    ptlv       = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    /**
     * Save received frame for Authenticator
     */
    (void)memcpy(pwps_info->last_message.message, (u8 *)(buf + SZ_EAP_WPS_FRAME_HEADER),
                 (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        ptlv_type = ntohs(ptlv->type);
        ptlv_len  = ntohs(ptlv->length);

        switch (ptlv_type)
        {
            case SC_Version:
                (void)memcpy(&pwps_info->enrollee.version, data, ptlv_len);
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, ptlv_len);
                if (pwps_info->enrollee.version2 > WPS_VERSION)
                {
                    wps_d("(DONE) Unknown WPS Version = 0x%x", pwps_info->enrollee.version2);
                }
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_DONE)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, ptlv_len);
                break;
            case SC_Registrar_Nonce:
                (void)memcpy(pwps_info->registrar.nonce, data, ptlv_len);
                break;
        }

        len  = ptlv_len + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS Start Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_request_start_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    int len;
    int ret;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    len            = wps_eap_message_header_prepare(pwps_info, EAP_REQUEST, pwps_info->id, WPS_Start);

    /* convert to network order */
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)len);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS Start Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_request_start_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    int status = WPS_STATUS_SUCCESS;
    PEAP_FRAME_HEADER peap_wps_frame;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)buf;

    if (memcmp(peap_wps_frame->vendor_id, wps_vendor_id, sizeof(wps_vendor_id)) != 0)
    {
        return WPS_STATUS_FAIL;
    }

    if (memcmp(peap_wps_frame->vendor_type, wps_vendor_type, sizeof(wps_vendor_type)) != 0)
    {
        return WPS_STATUS_FAIL;
    }

    if (peap_wps_frame->op_code != WPS_Start)
    {
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return status;
}

/**
 *  @brief  Prepare and Send WPS NACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param id           Frame identifier
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_nack_message_prepare(PWPS_INFO pwps_info, u8 id)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u8 *ptr;
    u16 msg_value_short, message_length = 0;
    int ret, offset                     = 0;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER)pwps_info->buffer;
    ptr            = pwps_info->buffer;

    offset = wps_message_common_attribute_prepare(
        pwps_info, id, ((wps_s->bss_type == BSS_TYPE_UAP)) ? EAP_REQUEST : EAP_RESPONSE, WPS_Nack, WPS_NACK);

    /* Configuration_Error */
    message_length += offset;
    ptr += offset;
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += (SZ_TLV_HEADER + ptlv->length);
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() We need to convert it
       back here */
    peap_wps_frame->length = htons(message_length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS ACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_ack_message_prepare(PWPS_INFO pwps_info)
{
    u16 message_length = 0;
    int ret, offset;
    u8 *ptr         = pwps_info->buffer;
    WPS_DATA *wps_s = (WPS_DATA *)&wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    ENTER();

    offset = wps_message_common_attribute_prepare(pwps_info, pwps_info->peer_id,
                                                  (wps_s->bss_type == BSS_TYPE_UAP) ? EAP_REQUEST : EAP_RESPONSE,
                                                  WPS_Ack, WPS_ACK);

    message_length += offset;
    ptr += offset;

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() */

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send EAP_FAIL Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eap_fail_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    u16 length;
    int ret;

    ENTER();

    peap_wps_frame             = (PEAP_FRAME_HEADER)pwps_info->buffer;
    peap_wps_frame->code       = EAP_FAILURE;
    peap_wps_frame->identifier = pwps_info->peer_id;
    length                     = 4;
    peap_wps_frame->length     = htons(length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *)pwps_info->buffer, (size_t)length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send EAPOL_START Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_eapol_start_prepare(PWPS_INFO pwps_info)
{
    ENTER();

    if (wps_eapol_txStart() < 0)
    {
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare and Send WPS NACK Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_nack_message_remap(PWPS_INFO pwps_info)
{
    ENTER();

    wps_nack_message_prepare(pwps_info, pwps_info->peer_id);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS ACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_ack_message_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len, tlv_type, tlv_length;

    ENTER();

    size       = ntohs(size);
    ptlv       = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    /**
     * Save received frame for Authenticator
     */
    (void)memcpy(pwps_info->last_message.message, (u8 *)(buf + SZ_EAP_WPS_FRAME_HEADER),
                 (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
                {
                    (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                }
                else if (pwps_info->role == WPS_REGISTRAR || (IS_DISCOVERY_REGISTRAR(pwps_info)))
                {
                    (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                }
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_ACK)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Registrar_Nonce:
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Process received WPS NACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_nack_message_process(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len, tlv_type, tlv_length;

    ENTER();

    size       = ntohs(size);
    ptlv       = (PTLV_DATA_HEADER)(buf + SZ_EAP_WPS_FRAME_HEADER);
    data       = (u8 *)ptlv;
    plast_byte = (u8 *)(buf + size);

    /**
     * Save received frame for Authenticator
     */
    (void)memcpy(pwps_info->last_message.message, (u8 *)(buf + SZ_EAP_WPS_FRAME_HEADER),
                 (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *)ptlv < (void *)plast_byte)
    {
        tlv_type   = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type)
        {
            case SC_Version:
                if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info)))
                {
                    (void)memcpy(&pwps_info->registrar.version, data, tlv_length);
                }
                else if (pwps_info->role == WPS_REGISTRAR || (IS_DISCOVERY_REGISTRAR(pwps_info)))
                {
                    (void)memcpy(&pwps_info->enrollee.version, data, tlv_length);
                }
                break;
            case SC_Vendor_Extension:
                wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
                break;
            case SC_Message_Type:
                wps_d("Message_Type = 0x%x", *data);
                if (*data != WPS_NACK)
                    return WPS_STATUS_FAIL;
                break;
            case SC_Enrollee_Nonce:
                (void)memcpy(pwps_info->enrollee.nonce, data, tlv_length);
                break;
            case SC_Registrar_Nonce:
                (void)memcpy(pwps_info->registrar.nonce, data, tlv_length);
                break;
            case SC_Configuration_Error:
                wps_d("SC_Configuration_Error(NACK): %d", ntohs(*(u16 *)data));
                break;
        }

        len  = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER)((u8 *)ptlv + len);

        data = (u8 *)ptlv;
        data += SZ_TLV_HEADER;
    } /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Dummy function for function table
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_dummy(PWPS_INFO pwps_info, u8 *buf, u16 size)
{
    ENTER();
    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/**
 *  @brief  Prepare Selected registrar config methods attribute.
 *
 *  @param  PWPS_IFO    A pointer to WPS_INFO structure
 *  @return             selected registrar config method value
 */
short wps_selected_registrar_config_method_prepare(PWPS_INFO pwps_info)
{
    u16 msg_value_short = 0, config_methods;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;

    pwps_info = wps_get_private_info();

    en_reg = ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    config_methods = en_reg->config_methods;

    if (en_reg->device_password_id == DEVICE_PASSWORD_PUSH_BUTTON)
        msg_value_short = config_methods & CONFIG_METHOD_PUSHBUTTON;
    else
        msg_value_short = config_methods & (CONFIG_METHOD_KEYPAD | CONFIG_METHOD_DISPLAY);
#if 0
    if (config_methods & CONFIG_METHOD_KEYPAD) {
        wps_d("Device is Rich UI device.");
        msg_value_short |= CONFIG_METHOD_KEYPAD;
    } else {
        wps_d("Device is Low UI device.");
    }
    if (config_methods & CONFIG_METHOD_DISPLAY) {
        msg_value_short |= CONFIG_METHOD_DISPLAY;
        msg_value_short |= CONFIG_METHOD_PHY_DISPLAY;
        msg_value_short |= CONFIG_METHOD_VIR_DISPLAY;
    }
    if (config_methods & CONFIG_METHOD_LABEL)
        msg_value_short |= CONFIG_METHOD_LABEL;
    if (en_reg->device_password_id == DEVICE_PASSWORD_PUSH_BUTTON) {
        msg_value_short |= CONFIG_METHOD_PUSHBUTTON;
        msg_value_short |= CONFIG_METHOD_VIRTUAL_PBC;
        wps_d(DEBUG_WLAN,
               "Push Button config method enabled on Registrar.");
    }
#endif
    return msg_value_short;
}

/**
 *  @brief  Prepare for Attribute needed for beacon
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE
 *                or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int wps_ap_beacon_prepare(u8 selectedRegistrar, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;
    ENTER();

    pwps_info = wps_get_private_info();

    en_reg = ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    offset = 0;

    /* OUI */
    ptr += offset;
    (void)memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Simple Config State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;

    /*msg_value_char = pwps_info->wps_device_state;*/
    msg_value_char = SC_CONFIGURED_STATE;

    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (selectedRegistrar == 1)
    {
        /* Selected Registrar */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_Selected_Registrar);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        *ptr = selectedRegistrar;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Password ID */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_Device_Password_ID);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;

        msg_value_short = htons(en_reg->updated_device_password_id);
        (void)memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Selected Registrar Config Methods */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_SelectedRegistrarConfigMethods);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;
        msg_value_short = htons(wps_selected_registrar_config_method_prepare(pwps_info));
        (void)memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }

    /* UUID */
    offset     = wps_attribute_uuid_prepare(pwps_info, ptr);
    ptlv       = (PTLV_DATA_HEADER)ptr;
    ptlv->type = htons(SC_UUID_E);
    message_length += offset;
    ptr += offset;

    if (pwps_info->wps_ap_setup_locked == WPS_SET)
    {
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_AP_Setup_Locked);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        msg_value_char = pwps_info->wps_ap_setup_locked;
        (void)memcpy(ptr, &msg_value_char, 1);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }
    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1)
        {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return message_length;
}

#if 0
/**
 *  @brief  Prepare for Attribute needed for probe request frame
 *
 *  @param ptr      A pointer to buffer which store this attribute
 *  @return         Length of Attribute TLV
 */
/* XXX: Actually we should do this for both Enrollee & Registrar */
int wps_sta_probe_request_prepare(u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;

    ENTER();

    pwps_info = wps_get_private_info();
    en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
          &pwps_info->enrollee : &pwps_info->registrar);
    offset = 0;

    /* OUI */
    ptr += offset;
    (void)memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Request Type */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Request_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char =
        ((pwps_info->role ==
          WPS_REGISTRAR) ? REQ_TYPE_REGISTRAR : REQ_TYPE_ENROLLEE);
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.config_methods);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* RF Bands */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, &pwps_info->enrollee.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0);    /* Not Associated */
    (void)memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += (SZ_TLV_HEADER + ptlv->length);
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;

    msg_value_short = htons(pwps_info->enrollee.updated_device_password_id);
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {

        /* Manufacture */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Manufacturer);
        ptlv->length = pwps_info->enrollee.manufacture_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.manufacture, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Model Name */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Model_Name);
        ptlv->length = pwps_info->enrollee.model_name_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.model_name, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Model Number */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Model_Number);
        ptlv->length = pwps_info->enrollee.model_number_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.model_number, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Name */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Device_Name);
        ptlv->length = pwps_info->enrollee.device_name_length;
        ptr += SZ_TLV_HEADER;
        (void)memcpy(ptr, pwps_info->enrollee.device_name, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length =
            ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

    }

    LEAVE();
    return message_length;
}
#endif

/**
 *  @brief  Prepare for Attribute needed for (Re)Assoc request frame
 *
 *  @param ptr      A pointer to buffer which store this attribute
 *  @return         Length of Attribute TLV
 */
int wps_sta_assoc_request_prepare(u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;

    ENTER();

    pwps_info = wps_get_private_info();
    en_reg    = ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);
    offset    = 0;

    (void)memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    wps_d("Mak: message_length 1 = %d\n", message_length);
    ptr += sizeof(wps_wifi_oui);

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    wps_d("Mak: message_length 2 = %d\n", message_length);
    ptr += offset;

    /* Request Type */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Request_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = ((pwps_info->role == WPS_REGISTRAR) ? REQ_TYPE_REGISTRAR : REQ_TYPE_ENROLLEE);
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    wps_d("Mak: message_length 3 = %d\n", message_length);
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wps_d("Mak: message_length 4 = %d\n", message_length);
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    LEAVE();
    return message_length;
}

/**
 *  @brief  Prepare for Attribute needed for probe response frame
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE
 *                or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int wps_ap_assoc_response_prepare(u8 selectedRegistrar, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;

    pwps_info = wps_get_private_info();
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);
    ENTER();

    offset = 0;

    /* OUI */
    ptr += offset;
    (void)memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Response Type */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Response_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = RESP_TYPE_AP;
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1)
        {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }
        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }
    LEAVE();
    return message_length;
}

/**
 *  @brief  Prepare for Attribute needed for probe response frame
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE
 *                or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int wps_ap_probe_response_prepare(u8 selectedRegistrar, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;

    pwps_info = wps_get_private_info();
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg =
        ((pwps_info->role == WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);
    ENTER();

    offset = 0;

    /* OUI */
    ptr += offset;
    (void)memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Simple Config State */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = SC_CONFIGURED_STATE;

    /*msg_value_char = pwps_info->wps_device_state;*/

    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (pwps_info->wps_ap_setup_locked == WPS_SET)
    {
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_AP_Setup_Locked);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        msg_value_char = pwps_info->wps_ap_setup_locked;
        (void)memcpy(ptr, &msg_value_char, 1);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }
    if (selectedRegistrar == 1)
    {
        /* Selected Registrar */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_Selected_Registrar);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        *ptr = selectedRegistrar;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Password ID */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_Device_Password_ID);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;

        msg_value_short = htons(en_reg->updated_device_password_id);
        (void)memcpy(ptr, &msg_value_short, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Selected Registrar Config Methods */
        ptlv         = (PTLV_DATA_HEADER)ptr;
        ptlv->type   = htons(SC_SelectedRegistrarConfigMethods);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;
        msg_value_short = htons(wps_selected_registrar_config_method_prepare(pwps_info));
        (void)memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }

    /* Response Type */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Response_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = RESP_TYPE_AP;
    (void)memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID */
    offset     = wps_attribute_uuid_prepare(pwps_info, ptr);
    ptlv       = (PTLV_DATA_HEADER)ptr;
    ptlv->type = htons(SC_UUID_E);
    message_length += offset;
    ptr += offset;

    /* Manufacture */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    (void)memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv         = (PTLV_DATA_HEADER)ptr;
    ptlv->type   = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    {
        if (en_reg->device_password_id == DEVICE_PASSWORD_PUSH_BUTTON)
            msg_value_short = htons(pwps_info->registrar.config_methods & CONFIG_METHOD_PUSHBUTTON);
        else
            msg_value_short =
                htons(pwps_info->registrar.config_methods & (CONFIG_METHOD_KEYPAD | CONFIG_METHOD_DISPLAY));
    }
    (void)memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0)
    {
        wfa_ven_tlv = (PTLV_DATA_HEADER)ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        (void)memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1)
        {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *)wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);
    }

    LEAVE();
    return message_length;
}

#if 0
/**
 *  @brief  Parsing Device Password ID
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @return             Device Password ID
 */
u16 wps_probe_response_device_password_id_parser(u8 *message, size_t size)
{
    u16 device_password_id = 0xffff;
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Version:
            break;
        case SC_Response_Type:
            break;
        case SC_UUID_E:
            break;
        case SC_UUID_R:
            break;
        case SC_Simple_Config_State:
            break;
        case SC_Manufacturer:
            break;
        case SC_Model_Name:
            break;
        case SC_Model_Number:
            break;
        case SC_Serial_Number:
            break;
        case SC_Primary_Device_Type:
            break;
        case SC_Device_Name:
            break;
        case SC_Config_Methods:
            break;
        case SC_Selected_Registrar:
            wps_d("SC_Selected_Registrar: %d",
                   *data);
            break;
        case SC_Device_Password_ID:
            wps_d("SC_Device_Password_ID");
            (void)memcpy(&device_password_id, data, sizeof(u16));
            device_password_id = ntohs(device_password_id);
            wps_d("device_password_id = 0x%x",
                   device_password_id);
            break;
        default:
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;

    /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }            /* while */

    LEAVE();
    return device_password_id;
}

/**
 *  @brief  Parsing Device Password ID
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @return             Device Password ID
 */
u16 wps_probe_request_device_password_id_parser(u8 *message, size_t size)
{
    u16 device_password_id = 0xffff;
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Device_Password_ID:
            wps_d("SC_Device_Password_ID");
            (void)memcpy(&device_password_id, data, sizeof(u16));
            device_password_id = ntohs(device_password_id);
            wps_d("device_password_id = 0x%x",
                   device_password_id);
            break;
        default:
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;

    /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }            /* while */

    LEAVE();
    return device_password_id;
}

/**
 *  @brief  Parsing UUID_E in WPS IE
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param uuid_e       A pointer to returned buffer
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int wps_probe_response_uuid_parser(u8 *message, size_t size, u8 *uuid_e)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        if (ptlv->type == SC_UUID_E) {
            wps_d("SC_UUID_E found !");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            (void)memcpy(uuid_e, ptr, ptlv->length);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        len = ptlv->length + SZ_TLV_HEADER;

    /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }            /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/**
 *  @brief  Parsing Config State in probe response
 *
 *  @param message        A pointer to buffer for parsing
 *  @param size            Length of buffer
 *  @param conf_state        A pointer to returned buffer
 *  @return            WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL
 *                              on fail
 */

int
wps_probe_response_conf_state_parser(u8 *message, size_t size, u8 *conf_state)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 tlv_type, tlv_len;

    ENTER();
    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_len = ntohs(ptlv->length);

        if (tlv_type == SC_Simple_Config_State) {
            wps_d("SC_CONF_STATE found !");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            *conf_state = *ptr;
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        ptlv =
            (PTLV_DATA_HEADER) ((u8 *) ptlv + tlv_len + SZ_TLV_HEADER);
    }            /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/**
 *  @brief  Parsing Selected Registrar config methods in probe response
 *
 *  @param message        A pointer to buffer for parsing
 *  @param size            Length of buffer
 *  @param config_method    A pointer to return buffer
 *  @return            WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL
 *                              on fail
 */

int
wps_probe_response_selected_registrar_config_method_parser(u8 *message,
                               size_t size,
                               u16 *config_method)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 tlv_type, tlv_len;

    ENTER();
    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_len = ntohs(ptlv->length);

        if (tlv_type == SC_SelectedRegistrarConfigMethods) {
            wps_d(DEBUG_WLAN,
                   "Selected Registrar config methods found !");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            (void)memcpy(config_method, ptr, 2);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        ptlv =
            (PTLV_DATA_HEADER) ((u8 *) ptlv + tlv_len + SZ_TLV_HEADER);
    }            /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/**
 *  @brief  Parsing Response Type in WPS IE
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param resp_type    A pointer to value
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_probe_response_resp_type_parser(u8 *message, size_t size, u8 *resp_type)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len, tlv_type, tlv_length;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        if (tlv_type == SC_Response_Type) {
            wps_d("SC_Response_Type found !");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            (void)memcpy(resp_type, ptr, tlv_length);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        len = tlv_length + SZ_TLV_HEADER;

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }            /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/**
 *  @brief  Parsing WPS2 Authorized MAC Attribute
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param mac_addr     A pointer to enrollee mac address
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_probe_response_authorized_enrollee_mac_parser(PWPS_INFO pwps_info,
                          u8 *message, u8 size)
{
    int ret = WPS_STATUS_SUCCESS;
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len;

    ENTER();

    wps_hexdump("WPS MAC Parser:", message, size);

    /*
     * skip IE_ID [1]/Length[1]/SC_OUI field[4]
     * Beginning from Version 104a[5], Simple config state 1044[5],
     * 1+1+4+5+5=16.
     */
    /* TODO */
    ptlv = (PTLV_DATA_HEADER) (message + 16);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *)ptlv < (void *)plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);
        ptr = (u8 *) ptlv + SZ_TLV_HEADER;
        if (ptlv->type == SC_Vendor_Extension) {

            ret =
                wps_process_attrib_vendor_ext(pwps_info, ptr,
                              ptlv->length);
            LEAVE();
            return ret;
        }

        len = ptlv->length + SZ_TLV_HEADER;

    /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }            /* while */

    LEAVE();
    return ret;
}
#endif
