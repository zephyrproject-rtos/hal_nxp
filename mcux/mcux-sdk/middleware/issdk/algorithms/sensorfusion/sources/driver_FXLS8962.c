/*
 * Copyright (c) 2015, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*! \file driver_FXLS8962.c
    \brief Provides init() and read() functions for the FXLS8962 3-axis accelerometer
*/

#include "board.h"                      // generated by Kinetis Expert.  Long term - merge sensor_board.h into this file
#include "sensor_fusion.h"              // Sensor fusion structures and types
#include "sensor_io_i2c.h"              // Required for registerreadlist_t / registerwritelist_t declarations
#include "sensor_drv.h"                 // Contains sensor state and error definitions
#include "fxls8962.h"                   // describes the FXLS8962 register definition and its bit mask
#include "drivers.h"                    // Device specific drivers supplied by NXP (can be replaced with user drivers)
#define FXLS8962_COUNTSPERG 512
#define FXLS8962_ACCEL_FIFO_SIZE 32

#if F_USING_ACCEL

// Command definition to read the WHO_AM_I value.
const registerreadlist_t    FXLS8962_WHO_AM_I_READ[] =
{
    { .readFrom = FXLS8962_WHO_AM_I, .numBytes = 1 }, __END_READ_DATA__
};

// Command definition to read the number of entries in the accel FIFO.
const registerreadlist_t    FXLS8962_INT_STATUS_READ[] =
{
    { .readFrom = FXLS8962_INT_STATUS, .numBytes = 1 }, __END_READ_DATA__
};

// Command definition to read the number of entries in the accel FIFO.
registerreadlist_t          FXLS8962_DATA_READ[] =
{
    { .readFrom = FXLS8962_OUT_X_LSB, .numBytes = 6 }, __END_READ_DATA__
};

// Each entry in a RegisterWriteList is composed of: register address, value to write, bit-mask to apply to write (0 enables)
const registerwritelist_t   FXLS8962_Initialization[] =
{
    // write 0000 0000 = 0x00 to SENS_CONFIG1 to place FXLS8962 into standby
    // [7-1]: Set when taking the part out of standby
    // [0]: ACTIVE=0 for standby
    { FXLS8962_SENS_CONFIG1, 0x00, 0x00 },

    // write 0101 0000 = 0x50 to SENS_CONFIG2 register to set High Performance Mode
    // [7-6]: WAKE_PM=01 for High Performance Mode
    // [5-4]: SLEEP_PM=01 for High Performance Mode
    // [3]: LE_BE=0 for Little Endian
    // [2]: BLOCK=0 for normal latching
    // [1]: AINC_TEMP=0 to not include temperature in auto increment
    // [0]: F_READ=0 for full register reads
    { FXLS8962_SENS_CONFIG2, 0x50, 0x00 },

     // write XXXX 0000 = to SENS_CONFIG3 register to set ODR
    // [7-4]: WAKE_ODR=1100 for 0.781Hz ODR and 4096x decimation from 3200Hz giving 0xC0
    // [7-4]: WAKE_ODR=1011 for 1.563Hz ODR and 12048x decimation from 3200Hz giving 0xB0
    // [7-4]: WAKE_ODR=1010 for 3.125Hz ODR and 1024x decimation from 3200Hz giving 0xA0
    // [7-4]: WAKE_ODR=1001 for 6.25Hz ODR and 512x decimation from 3200Hz giving 0x90
    // [7-4]: WAKE_ODR=1000 for 12.5Hz ODR and 256x decimation from 3200Hz giving 0x80
    // [7-4]: WAKE_ODR=0111 for 25Hz ODR and 128x decimation from 3200Hz giving 0x70
    // [7-4]: WAKE_ODR=0110 for 50Hz ODR and 64x decimation from 3200Hz giving 0x60
    // [7-4]: WAKE_ODR=0101 for 100Hz ODR and 32x decimation from 3200Hz giving 0x50
    // [7-4]: WAKE_ODR=0100 for 200Hz ODR and 16x decimation from 3200Hz giving 0x40
    // [7-4]: WAKE_ODR=0011 for 400Hz ODR and 8x decimation from 3200Hz giving 0x30
    // [7-4]: WAKE_ODR=0010 for 800Hz ODR and 4x decimation from 3200Hz giving 0x20
    // [7-4]: WAKE_ODR=0001 for 1600Hz ODR and 2x decimation from 3200Hz giving 0x10
    // [7-4]: WAKE_ODR=0000 for 3200Hz ODR and 1x decimation from 3200Hz giving 0x00
    // [3-0]: SLEEP_ODR=0000
#if   (ACCEL_ODR_HZ <= 1) // select 0.781Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0xC0, 0x00 },
#elif (ACCEL_ODR_HZ <= 2) // select 1.5625Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x80, 0x00 },
#elif (ACCEL_ODR_HZ <= 3) // select 3.125Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0xA0, 0x00 },
#elif (ACCEL_ODR_HZ <= 6) // select 6.25Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x90, 0x00 },
#elif (ACCEL_ODR_HZ <= 12) // select 12.5Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x80, 0x00 },
#elif (ACCEL_ODR_HZ <= 25) // select 25Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x70, 0x00 },
#elif (ACCEL_ODR_HZ <= 50) // select 50Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x60, 0x00 },
#elif (ACCEL_ODR_HZ <= 100) // select 100Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x50, 0x00 },
#elif (ACCEL_ODR_HZ <= 200) // select 200Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x40, 0x00 },
#elif (ACCEL_ODR_HZ <= 400) // select 400Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x30, 0x00 },
#elif (ACCEL_ODR_HZ <= 800) // select 800Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x20, 0x00 },
#elif (ACCEL_ODR_HZ <= 1600) // select 1600Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x10, 0x00 },
#else  // select 3200Hz ODR
    	{ FXLS8962_SENS_CONFIG3, 0x00, 0x00 },
#endif

    // write 0000 0011 = 0x03 to SENS_CONFIG1 to configure 4g mode and Active mode
    // [7]: RST=0 for no software reset
    // [6-5]: ST_AXIS_SEL=00 to disable self test
    // [4]: ST_POL=0 (default)
    // [3]: AWS_EN=0 (default)
    // [2-1]: FSR=01 for 4g mode
    // [1]: ACTIVE=1 for standby
    { FXLS8962_SENS_CONFIG1, 0x03, 0x00 },
    __END_WRITE_DATA__
};

// All sensor drivers and initialization functions have the same prototype.
// sfg is a pointer to the master "global" sensor fusion structure.
// sensor = pointer to linked list element used by the sensor fusion subsystem to specify required sensors

// sfg = pointer to top level (generally global) data structure for sensor fusion
int8_t FXLS8962_Init(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    int32_t status;
    uint8_t reg;
    status = Register_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8962_WHO_AM_I, 1, &reg);
    if (status==SENSOR_ERROR_NONE) {
        if (reg==FXLS8962_WHOAMI_VALUE) {
            sfg->Accel.iWhoAmI = reg;
        } else {
            return(SENSOR_ERROR_INIT);
        }
      } else {
        return(status);
    }

    // Configure and start the FXLS8962 sensor.  This does multiple register writes
    // (see FXLS8962_Initialization definition above)
    status = Sensor_I2C_Write(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8962_Initialization );

    // Stash some needed constants in the SF data structure for this sensor
    sfg->Accel.iCountsPerg = FXLS8962_COUNTSPERG;
    sfg->Accel.fgPerCount = 1.0F / FXLS8962_COUNTSPERG;
    sfg->Accel.fgPerCount = 1.0F / FXLS8962_COUNTSPERG;

    sensor->isInitialized = F_USING_ACCEL;
    sfg->Accel.isEnabled = true;

    return (status);
}

int8_t FXLS8962_Read(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    uint8_t                     I2C_Buffer[6 * FXLS8962_ACCEL_FIFO_SIZE];    // I2C read buffer
    int8_t                      status;         // I2C transaction status
    uint8_t                     sensor_data_ready = 0;
    int16_t                     sample[3];

    if(sensor->isInitialized != F_USING_ACCEL)
    {
        return SENSOR_ERROR_INIT;
    }

    // read the FXLS8962_BUF_STATUS register (mapped to STATUS) and extract number of measurements available (lower 6 bits)
    status =  Sensor_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8962_INT_STATUS_READ, I2C_Buffer );
    if (status==SENSOR_ERROR_NONE) {
        sensor_data_ready = I2C_Buffer[0] & 0x80;
        // return if there are no measurements in the sensor FIFO.
        // this will only occur when the FAST_LOOP_HZ equals or exceeds ACCEL_ODR_HZ
        if  (sensor_data_ready == 0) return status;
    } else {
        return(status);
    }

    status =  Sensor_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8962_DATA_READ, I2C_Buffer );

    if (status==SENSOR_ERROR_NONE) {
         // place the 6 bytes read into the 16 bit accelerometer structure
         sample[CHX] = (I2C_Buffer[1] << 8) | I2C_Buffer[0];
         sample[CHY] = (I2C_Buffer[3] << 8) | I2C_Buffer[2];
         sample[CHZ] = (I2C_Buffer[5] << 8) | I2C_Buffer[4];
         conditionSample(sample);  // truncate negative values to -32767
         addToFifo((union FifoSensor*) &(sfg->Accel), ACCEL_FIFO_SIZE, sample);
    }

    return (status);
}


// Each entry in a RegisterWriteList is composed of: register address, value to write, bit-mask to apply to write (0 enables)
const registerwritelist_t   FXLS8962_IDLE[] =
{
  // Set ACTIVE = other bits unchanged
  { FXLS8962_SENS_CONFIG1, 0x00, 0x01 },
    __END_WRITE_DATA__
};

// FXLS8962_Idle places the sensor into Standby mode (see datasheet for wakeup time)
int8_t FXLS8962_Idle(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    int32_t     status;
    if(sensor->isInitialized == F_USING_ACCEL) {
        status = Sensor_I2C_Write(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8962_IDLE );
        sensor->isInitialized = 0;
        sfg->Accel.isEnabled = false;
    } else {
      return SENSOR_ERROR_INIT;
    }
    return status;
}
#endif // if F_USING_ACCEL
