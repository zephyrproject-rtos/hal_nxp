<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCUX CLNS: mcuxClMath_Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUX CLNS
   </div>
   <div id="projectbrief">MCUX Crypto Library Normal Secure</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__mcux_cl_math___functions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mcuxClMath_Functions<div class="ingroups"><a class="el" href="group__mcux_cl_math.html">mcuxClMath</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines all functions of <a class="el" href="group__mcux_cl_math.html">mcuxClMath</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4c4f5d39d9afbaa83550c0e4dcd190db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga4c4f5d39d9afbaa83550c0e4dcd190db">MCUXCLMATH_FP_INITLOCALUPTRT</a>(i3_i2_i1_i0,  i7_i6_i5_i4,  localPtrUptrt,  noOfIndices)</td></tr>
<tr class="memdesc:ga4c4f5d39d9afbaa83550c0e4dcd190db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#ga352cef03d92210d17e6f7973f3e1b6b9" title="Initializes the new UPTRT and returns the address of existing UPTRT.">mcuxClMath_InitLocalUptrt</a> with flow protection.  <a href="#ga4c4f5d39d9afbaa83550c0e4dcd190db">More...</a><br /></td></tr>
<tr class="separator:ga4c4f5d39d9afbaa83550c0e4dcd190db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e286eeaee0c98c3a1eb1a325632787f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga5e286eeaee0c98c3a1eb1a325632787f">MCUXCLMATH_FP_LEADINGZEROS</a>(iX)</td></tr>
<tr class="memdesc:ga5e286eeaee0c98c3a1eb1a325632787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#gac216619c765747a5573b7f2837b6b47a" title="Counts number of leading zeros of operand in the given buffer (length = ps1 OPLEN).">mcuxClMath_LeadingZeros</a> with flow protection.  <a href="#ga5e286eeaee0c98c3a1eb1a325632787f">More...</a><br /></td></tr>
<tr class="separator:ga5e286eeaee0c98c3a1eb1a325632787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e95ef7352377d28593d19cfa19e8f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf8e95ef7352377d28593d19cfa19e8f7">MCUXCLMATH_FP_TRAILINGZEROS</a>(iX)</td></tr>
<tr class="memdesc:gaf8e95ef7352377d28593d19cfa19e8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#gaceede49c0bd63319311ebff84d5fb2aa" title="Counts number of trailing zeros of operand in the given buffer (length = ps1 OPLEN).">mcuxClMath_TrailingZeros</a> with flow protection.  <a href="#gaf8e95ef7352377d28593d19cfa19e8f7">More...</a><br /></td></tr>
<tr class="separator:gaf8e95ef7352377d28593d19cfa19e8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaadd4485b0f1db32b6da6e6b7a2e6cc11">MCUXCLMATH_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga70edadc0775e547faf48429664aacf06" title="Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1,...">mcuxClMath_ShiftModulus</a>.  <a href="#gaadd4485b0f1db32b6da6e6b7a2e6cc11">More...</a><br /></td></tr>
<tr class="separator:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga35df7cdad4c81c5e276f373c70c571d0">MCUXCLMATH_FP_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:ga35df7cdad4c81c5e276f373c70c571d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga70edadc0775e547faf48429664aacf06" title="Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1,...">mcuxClMath_ShiftModulus</a> with flow protection.  <a href="#ga35df7cdad4c81c5e276f373c70c571d0">More...</a><br /></td></tr>
<tr class="separator:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab588855e23f750a4c9f7533b54a11325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gab588855e23f750a4c9f7533b54a11325">MCUXCLMATH_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gab588855e23f750a4c9f7533b54a11325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gafe27ab61e1477e3adb92712ef0aaeee0" title="Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion,...">mcuxClMath_NDash</a>.  <a href="#gab588855e23f750a4c9f7533b54a11325">More...</a><br /></td></tr>
<tr class="separator:gab588855e23f750a4c9f7533b54a11325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0d390f4eb5728edfd764936aeee313"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gafa0d390f4eb5728edfd764936aeee313">MCUXCLMATH_FP_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gafa0d390f4eb5728edfd764936aeee313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gafe27ab61e1477e3adb92712ef0aaeee0" title="Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion,...">mcuxClMath_NDash</a> with flow protection.  <a href="#gafa0d390f4eb5728edfd764936aeee313">More...</a><br /></td></tr>
<tr class="separator:gafa0d390f4eb5728edfd764936aeee313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666d3347d6f96a09b791355e596de46d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga666d3347d6f96a09b791355e596de46d">MCUXCLMATH_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga666d3347d6f96a09b791355e596de46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga1c452a7ff7f0666825f923e7b96a5a46" title="Calculates Q * Q&#39; mod n, where Q = 256^(ps1 OPLEN) mod n, and Q&#39; = 256^len mod n.">mcuxClMath_QDash</a>.  <a href="#ga666d3347d6f96a09b791355e596de46d">More...</a><br /></td></tr>
<tr class="separator:ga666d3347d6f96a09b791355e596de46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7703703d552c5446acdf38d82cd81971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga7703703d552c5446acdf38d82cd81971">MCUXCLMATH_FP_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga7703703d552c5446acdf38d82cd81971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga1c452a7ff7f0666825f923e7b96a5a46" title="Calculates Q * Q&#39; mod n, where Q = 256^(ps1 OPLEN) mod n, and Q&#39; = 256^len mod n.">mcuxClMath_QDash</a> with flow protection.  <a href="#ga7703703d552c5446acdf38d82cd81971">More...</a><br /></td></tr>
<tr class="separator:ga7703703d552c5446acdf38d82cd81971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga4ee6d9b078ecc35a081a3a8cdbec0968">MCUXCLMATH_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga614b5ea66996bc85636ee1dd8d135491" title="Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n.">mcuxClMath_QSquared</a>.  <a href="#ga4ee6d9b078ecc35a081a3a8cdbec0968">More...</a><br /></td></tr>
<tr class="separator:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd348426e9998703dc6f93194a62f80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gadcd348426e9998703dc6f93194a62f80">MCUXCLMATH_FP_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:gadcd348426e9998703dc6f93194a62f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga614b5ea66996bc85636ee1dd8d135491" title="Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n.">mcuxClMath_QSquared</a> with flow protection.  <a href="#gadcd348426e9998703dc6f93194a62f80">More...</a><br /></td></tr>
<tr class="separator:gadcd348426e9998703dc6f93194a62f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59866fd485a59868a2a594a5858f1de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaa59866fd485a59868a2a594a5858f1de">MCUXCLMATH_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gaa59866fd485a59868a2a594a5858f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gae4cdfcc801cef8e8546a309e9f102273" title="Calculates modular inversion, X^(-1) mod n.">mcuxClMath_ModInv</a>.  <a href="#gaa59866fd485a59868a2a594a5858f1de">More...</a><br /></td></tr>
<tr class="separator:gaa59866fd485a59868a2a594a5858f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab456571414ef2f49a91b61f0c91009ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gab456571414ef2f49a91b61f0c91009ba">MCUXCLMATH_FP_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gab456571414ef2f49a91b61f0c91009ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gae4cdfcc801cef8e8546a309e9f102273" title="Calculates modular inversion, X^(-1) mod n.">mcuxClMath_ModInv</a> with flow protection.  <a href="#gab456571414ef2f49a91b61f0c91009ba">More...</a><br /></td></tr>
<tr class="separator:gab456571414ef2f49a91b61f0c91009ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga3ee39987ba7de0e36abc848d77b4eaa3">MCUXCLMATH_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga08c5acc0cc1b9a7a9467b533669a881e" title="Calculates modular reduction with even modulus, x mod n, where n is even.">mcuxClMath_ReduceModEven</a>.  <a href="#ga3ee39987ba7de0e36abc848d77b4eaa3">More...</a><br /></td></tr>
<tr class="separator:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaed2b24ff10b916eb07a842a2a05ad341">MCUXCLMATH_FP_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:gaed2b24ff10b916eb07a842a2a05ad341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga08c5acc0cc1b9a7a9467b533669a881e" title="Calculates modular reduction with even modulus, x mod n, where n is even.">mcuxClMath_ReduceModEven</a> with flow protection.  <a href="#gaed2b24ff10b916eb07a842a2a05ad341">More...</a><br /></td></tr>
<tr class="separator:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga82842f4b45c0d86e4c2d6d29e23c259b">MCUXCLMATH_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga010598433e6c335c23e561795725718a" title="Calculates modular exponentiation with left-to-right binary square and multiply algorithm.">mcuxClMath_ModExp_SqrMultL2R</a>.  <a href="#ga82842f4b45c0d86e4c2d6d29e23c259b">More...</a><br /></td></tr>
<tr class="separator:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga9f0c8d67f0c192341fbf9ac436f02173">MCUXCLMATH_FP_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga010598433e6c335c23e561795725718a" title="Calculates modular exponentiation with left-to-right binary square and multiply algorithm.">mcuxClMath_ModExp_SqrMultL2R</a> with flow protection.  <a href="#ga9f0c8d67f0c192341fbf9ac436f02173">More...</a><br /></td></tr>
<tr class="separator:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f34036f34027bdbd97cda0e285fdcd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga7f34036f34027bdbd97cda0e285fdcd2">MCUXCLMATH_SECMODEXP</a>(pExp,  pExpTemp,  byteLenExp,  iR,  iX,  iN,  iTE,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga7f34036f34027bdbd97cda0e285fdcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf0eecd504a144ccef7606bbf0a2dcc5d" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a>.  <a href="#ga7f34036f34027bdbd97cda0e285fdcd2">More...</a><br /></td></tr>
<tr class="separator:ga7f34036f34027bdbd97cda0e285fdcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c64aaec884efeb2eafe87c416b58ebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga1c64aaec884efeb2eafe87c416b58ebc">MCUXCLMATH_FP_SECMODEXP</a>(pExp,  pExpTemp,  byteLenExp,  iR,  iX,  iN,  iTE,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga1c64aaec884efeb2eafe87c416b58ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf0eecd504a144ccef7606bbf0a2dcc5d" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a> with flow protection.  <a href="#ga1c64aaec884efeb2eafe87c416b58ebc">More...</a><br /></td></tr>
<tr class="separator:ga1c64aaec884efeb2eafe87c416b58ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e3752b423bddda804b2ec4c164e6390"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga2e3752b423bddda804b2ec4c164e6390">MCUXCLMATH_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  pkcByteLenX,  pkcByteLenY)</td></tr>
<tr class="memdesc:ga2e3752b423bddda804b2ec4c164e6390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf2f74fa630792978ea7f58731b5bfdad" title="TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize.">mcuxClMath_ExactDivideOdd</a>.  <a href="#ga2e3752b423bddda804b2ec4c164e6390">More...</a><br /></td></tr>
<tr class="separator:ga2e3752b423bddda804b2ec4c164e6390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdaa1e49f5eb217f68ad98e4464c397"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gabcdaa1e49f5eb217f68ad98e4464c397">MCUXCLMATH_FP_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  pkcByteLenX,  pkcByteLenY)</td></tr>
<tr class="memdesc:gabcdaa1e49f5eb217f68ad98e4464c397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf2f74fa630792978ea7f58731b5bfdad" title="TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize.">mcuxClMath_ExactDivideOdd</a> with flow protection.  <a href="#gabcdaa1e49f5eb217f68ad98e4464c397">More...</a><br /></td></tr>
<tr class="separator:gabcdaa1e49f5eb217f68ad98e4464c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga604b79f6ec8a9f0cc2ccae1e58510bcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga604b79f6ec8a9f0cc2ccae1e58510bcc">MCUXCLMATH_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  pkcByteLenX,  pkcByteLenY)</td></tr>
<tr class="memdesc:ga604b79f6ec8a9f0cc2ccae1e58510bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga39240333bddf11bceeea47e029a30ba8" title="Exact division.">mcuxClMath_ExactDivide</a>.  <a href="#ga604b79f6ec8a9f0cc2ccae1e58510bcc">More...</a><br /></td></tr>
<tr class="separator:ga604b79f6ec8a9f0cc2ccae1e58510bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad820a29fd45470c09c3ae3e604d4e6c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gad820a29fd45470c09c3ae3e604d4e6c0">MCUXCLMATH_FP_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  pkcByteLenX,  pkcByteLenY)</td></tr>
<tr class="memdesc:gad820a29fd45470c09c3ae3e604d4e6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga39240333bddf11bceeea47e029a30ba8" title="Exact division.">mcuxClMath_ExactDivide</a> with flow protection.  <a href="#gad820a29fd45470c09c3ae3e604d4e6c0">More...</a><br /></td></tr>
<tr class="separator:gad820a29fd45470c09c3ae3e604d4e6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga352cef03d92210d17e6f7973f3e1b6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga352cef03d92210d17e6f7973f3e1b6b9">mcuxClMath_InitLocalUptrt</a> (uint32_t i3_i2_i1_i0, uint32_t i7_i6_i5_i4, uint16_t *localPtrUptrt, uint8_t noOfIndices, const uint16_t **oldPtrUptrt)</td></tr>
<tr class="memdesc:ga352cef03d92210d17e6f7973f3e1b6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the new UPTRT and returns the address of existing UPTRT.  <a href="#ga352cef03d92210d17e6f7973f3e1b6b9">More...</a><br /></td></tr>
<tr class="separator:ga352cef03d92210d17e6f7973f3e1b6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac216619c765747a5573b7f2837b6b47a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gac216619c765747a5573b7f2837b6b47a">mcuxClMath_LeadingZeros</a> (uint8_t iX, uint32_t *nLeadingZeros)</td></tr>
<tr class="memdesc:gac216619c765747a5573b7f2837b6b47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of leading zeros of operand in the given buffer (length = ps1 OPLEN).  <a href="#gac216619c765747a5573b7f2837b6b47a">More...</a><br /></td></tr>
<tr class="separator:gac216619c765747a5573b7f2837b6b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceede49c0bd63319311ebff84d5fb2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaceede49c0bd63319311ebff84d5fb2aa">mcuxClMath_TrailingZeros</a> (uint8_t iX, uint32_t *nTrailingZeros)</td></tr>
<tr class="memdesc:gaceede49c0bd63319311ebff84d5fb2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of trailing zeros of operand in the given buffer (length = ps1 OPLEN).  <a href="#gaceede49c0bd63319311ebff84d5fb2aa">More...</a><br /></td></tr>
<tr class="separator:gaceede49c0bd63319311ebff84d5fb2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70edadc0775e547faf48429664aacf06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga70edadc0775e547faf48429664aacf06">mcuxClMath_ShiftModulus</a> (uint16_t iNShifted_iN)</td></tr>
<tr class="memdesc:ga70edadc0775e547faf48429664aacf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1, and stores the result in the buffer specified.  <a href="#ga70edadc0775e547faf48429664aacf06">More...</a><br /></td></tr>
<tr class="separator:ga70edadc0775e547faf48429664aacf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe27ab61e1477e3adb92712ef0aaeee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gafe27ab61e1477e3adb92712ef0aaeee0">mcuxClMath_NDash</a> (uint16_t iN_iT)</td></tr>
<tr class="memdesc:gafe27ab61e1477e3adb92712ef0aaeee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion, ...) with odd modulus.  <a href="#gafe27ab61e1477e3adb92712ef0aaeee0">More...</a><br /></td></tr>
<tr class="separator:gafe27ab61e1477e3adb92712ef0aaeee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c452a7ff7f0666825f923e7b96a5a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga1c452a7ff7f0666825f923e7b96a5a46">mcuxClMath_QDash</a> (uint32_t iQDash_iNShifted_iN_iT, uint16_t len)</td></tr>
<tr class="memdesc:ga1c452a7ff7f0666825f923e7b96a5a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates Q * Q' mod n, where Q = 256^(ps1 OPLEN) mod n, and Q' = 256^len mod n.  <a href="#ga1c452a7ff7f0666825f923e7b96a5a46">More...</a><br /></td></tr>
<tr class="separator:ga1c452a7ff7f0666825f923e7b96a5a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614b5ea66996bc85636ee1dd8d135491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga614b5ea66996bc85636ee1dd8d135491">mcuxClMath_QSquared</a> (uint32_t iQSqr_iNShifted_iN_iT)</td></tr>
<tr class="memdesc:ga614b5ea66996bc85636ee1dd8d135491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n.  <a href="#ga614b5ea66996bc85636ee1dd8d135491">More...</a><br /></td></tr>
<tr class="separator:ga614b5ea66996bc85636ee1dd8d135491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cdfcc801cef8e8546a309e9f102273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gae4cdfcc801cef8e8546a309e9f102273">mcuxClMath_ModInv</a> (uint32_t iR_iX_iN_iT)</td></tr>
<tr class="memdesc:gae4cdfcc801cef8e8546a309e9f102273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular inversion, X^(-1) mod n.  <a href="#gae4cdfcc801cef8e8546a309e9f102273">More...</a><br /></td></tr>
<tr class="separator:gae4cdfcc801cef8e8546a309e9f102273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c5acc0cc1b9a7a9467b533669a881e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga08c5acc0cc1b9a7a9467b533669a881e">mcuxClMath_ReduceModEven</a> (uint32_t iR_iX_iN_iT0, uint32_t iT1_iT2_iT3)</td></tr>
<tr class="memdesc:ga08c5acc0cc1b9a7a9467b533669a881e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular reduction with even modulus, x mod n, where n is even.  <a href="#ga08c5acc0cc1b9a7a9467b533669a881e">More...</a><br /></td></tr>
<tr class="separator:ga08c5acc0cc1b9a7a9467b533669a881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010598433e6c335c23e561795725718a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga010598433e6c335c23e561795725718a">mcuxClMath_ModExp_SqrMultL2R</a> (const uint8_t *pExp, uint32_t byteLenExp, uint32_t iR_iX_iN_iT)</td></tr>
<tr class="memdesc:ga010598433e6c335c23e561795725718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular exponentiation with left-to-right binary square and multiply algorithm.  <a href="#ga010598433e6c335c23e561795725718a">More...</a><br /></td></tr>
<tr class="separator:ga010598433e6c335c23e561795725718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0eecd504a144ccef7606bbf0a2dcc5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf0eecd504a144ccef7606bbf0a2dcc5d">mcuxClMath_SecModExp</a> (const uint8_t *pExp, uint32_t *pExpTemp, uint32_t byteLenExp, uint32_t iT3_iX_iT2_iT1, uint32_t iN_iTE_iT0_iR)</td></tr>
<tr class="memdesc:gaf0eecd504a144ccef7606bbf0a2dcc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Securely calculates modular exponentiation.  <a href="#gaf0eecd504a144ccef7606bbf0a2dcc5d">More...</a><br /></td></tr>
<tr class="separator:gaf0eecd504a144ccef7606bbf0a2dcc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f74fa630792978ea7f58731b5bfdad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf2f74fa630792978ea7f58731b5bfdad">mcuxClMath_ExactDivideOdd</a> (uint32_t iR_iX_iY_iT, uint32_t pkcByteLenX, uint32_t pkcByteLenY)</td></tr>
<tr class="memdesc:gaf2f74fa630792978ea7f58731b5bfdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize.  <a href="#gaf2f74fa630792978ea7f58731b5bfdad">More...</a><br /></td></tr>
<tr class="separator:gaf2f74fa630792978ea7f58731b5bfdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39240333bddf11bceeea47e029a30ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga39240333bddf11bceeea47e029a30ba8">mcuxClMath_ExactDivide</a> (uint32_t iR_iX_iY_iT, uint32_t pkcByteLenX, uint32_t pkcByteLenY)</td></tr>
<tr class="memdesc:ga39240333bddf11bceeea47e029a30ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact division.  <a href="#ga39240333bddf11bceeea47e029a30ba8">More...</a><br /></td></tr>
<tr class="separator:ga39240333bddf11bceeea47e029a30ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Defines all functions of <a class="el" href="group__mcux_cl_math.html">mcuxClMath</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4c4f5d39d9afbaa83550c0e4dcd190db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c4f5d39d9afbaa83550c0e4dcd190db">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_INITLOCALUPTRT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_INITLOCALUPTRT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i3_i2_i1_i0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i7_i6_i5_i4, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">localPtrUptrt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">noOfIndices&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#ga352cef03d92210d17e6f7973f3e1b6b9" title="Initializes the new UPTRT and returns the address of existing UPTRT.">mcuxClMath_InitLocalUptrt</a> with flow protection. </p>

</div>
</div>
<a id="ga5e286eeaee0c98c3a1eb1a325632787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e286eeaee0c98c3a1eb1a325632787f">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_LEADINGZEROS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_LEADINGZEROS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#gac216619c765747a5573b7f2837b6b47a" title="Counts number of leading zeros of operand in the given buffer (length = ps1 OPLEN).">mcuxClMath_LeadingZeros</a> with flow protection. </p>

</div>
</div>
<a id="gaf8e95ef7352377d28593d19cfa19e8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e95ef7352377d28593d19cfa19e8f7">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_TRAILINGZEROS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_TRAILINGZEROS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to call <a class="el" href="group__mcux_cl_math___functions.html#gaceede49c0bd63319311ebff84d5fb2aa" title="Counts number of trailing zeros of operand in the given buffer (length = ps1 OPLEN).">mcuxClMath_TrailingZeros</a> with flow protection. </p>

</div>
</div>
<a id="gaadd4485b0f1db32b6da6e6b7a2e6cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd4485b0f1db32b6da6e6b7a2e6cc11">&#9670;&nbsp;</a></span>MCUXCLMATH_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga70edadc0775e547faf48429664aacf06" title="Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1,...">mcuxClMath_ShiftModulus</a>. </p>

</div>
</div>
<a id="ga35df7cdad4c81c5e276f373c70c571d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35df7cdad4c81c5e276f373c70c571d0">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga70edadc0775e547faf48429664aacf06" title="Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1,...">mcuxClMath_ShiftModulus</a> with flow protection. </p>

</div>
</div>
<a id="gab588855e23f750a4c9f7533b54a11325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab588855e23f750a4c9f7533b54a11325">&#9670;&nbsp;</a></span>MCUXCLMATH_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gafe27ab61e1477e3adb92712ef0aaeee0" title="Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion,...">mcuxClMath_NDash</a>. </p>

</div>
</div>
<a id="gafa0d390f4eb5728edfd764936aeee313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0d390f4eb5728edfd764936aeee313">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gafe27ab61e1477e3adb92712ef0aaeee0" title="Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion,...">mcuxClMath_NDash</a> with flow protection. </p>

</div>
</div>
<a id="ga666d3347d6f96a09b791355e596de46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666d3347d6f96a09b791355e596de46d">&#9670;&nbsp;</a></span>MCUXCLMATH_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga1c452a7ff7f0666825f923e7b96a5a46" title="Calculates Q * Q&#39; mod n, where Q = 256^(ps1 OPLEN) mod n, and Q&#39; = 256^len mod n.">mcuxClMath_QDash</a>. </p>

</div>
</div>
<a id="ga7703703d552c5446acdf38d82cd81971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7703703d552c5446acdf38d82cd81971">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga1c452a7ff7f0666825f923e7b96a5a46" title="Calculates Q * Q&#39; mod n, where Q = 256^(ps1 OPLEN) mod n, and Q&#39; = 256^len mod n.">mcuxClMath_QDash</a> with flow protection. </p>

</div>
</div>
<a id="ga4ee6d9b078ecc35a081a3a8cdbec0968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee6d9b078ecc35a081a3a8cdbec0968">&#9670;&nbsp;</a></span>MCUXCLMATH_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga614b5ea66996bc85636ee1dd8d135491" title="Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n.">mcuxClMath_QSquared</a>. </p>

</div>
</div>
<a id="gadcd348426e9998703dc6f93194a62f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd348426e9998703dc6f93194a62f80">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga614b5ea66996bc85636ee1dd8d135491" title="Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n.">mcuxClMath_QSquared</a> with flow protection. </p>

</div>
</div>
<a id="gaa59866fd485a59868a2a594a5858f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa59866fd485a59868a2a594a5858f1de">&#9670;&nbsp;</a></span>MCUXCLMATH_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gae4cdfcc801cef8e8546a309e9f102273" title="Calculates modular inversion, X^(-1) mod n.">mcuxClMath_ModInv</a>. </p>

</div>
</div>
<a id="gab456571414ef2f49a91b61f0c91009ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab456571414ef2f49a91b61f0c91009ba">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gae4cdfcc801cef8e8546a309e9f102273" title="Calculates modular inversion, X^(-1) mod n.">mcuxClMath_ModInv</a> with flow protection. </p>

</div>
</div>
<a id="ga3ee39987ba7de0e36abc848d77b4eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee39987ba7de0e36abc848d77b4eaa3">&#9670;&nbsp;</a></span>MCUXCLMATH_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga08c5acc0cc1b9a7a9467b533669a881e" title="Calculates modular reduction with even modulus, x mod n, where n is even.">mcuxClMath_ReduceModEven</a>. </p>

</div>
</div>
<a id="gaed2b24ff10b916eb07a842a2a05ad341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2b24ff10b916eb07a842a2a05ad341">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga08c5acc0cc1b9a7a9467b533669a881e" title="Calculates modular reduction with even modulus, x mod n, where n is even.">mcuxClMath_ReduceModEven</a> with flow protection. </p>

</div>
</div>
<a id="ga82842f4b45c0d86e4c2d6d29e23c259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82842f4b45c0d86e4c2d6d29e23c259b">&#9670;&nbsp;</a></span>MCUXCLMATH_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga010598433e6c335c23e561795725718a" title="Calculates modular exponentiation with left-to-right binary square and multiply algorithm.">mcuxClMath_ModExp_SqrMultL2R</a>. </p>

</div>
</div>
<a id="ga9f0c8d67f0c192341fbf9ac436f02173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f0c8d67f0c192341fbf9ac436f02173">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga010598433e6c335c23e561795725718a" title="Calculates modular exponentiation with left-to-right binary square and multiply algorithm.">mcuxClMath_ModExp_SqrMultL2R</a> with flow protection. </p>

</div>
</div>
<a id="ga7f34036f34027bdbd97cda0e285fdcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f34036f34027bdbd97cda0e285fdcd2">&#9670;&nbsp;</a></span>MCUXCLMATH_SECMODEXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SECMODEXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExpTemp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iTE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf0eecd504a144ccef7606bbf0a2dcc5d" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a>. </p>

</div>
</div>
<a id="ga1c64aaec884efeb2eafe87c416b58ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c64aaec884efeb2eafe87c416b58ebc">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_SECMODEXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_SECMODEXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExpTemp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iTE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf0eecd504a144ccef7606bbf0a2dcc5d" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a> with flow protection. </p>

</div>
</div>
<a id="ga2e3752b423bddda804b2ec4c164e6390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e3752b423bddda804b2ec4c164e6390">&#9670;&nbsp;</a></span>MCUXCLMATH_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenY&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf2f74fa630792978ea7f58731b5bfdad" title="TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize.">mcuxClMath_ExactDivideOdd</a>. </p>

</div>
</div>
<a id="gabcdaa1e49f5eb217f68ad98e4464c397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcdaa1e49f5eb217f68ad98e4464c397">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenY&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#gaf2f74fa630792978ea7f58731b5bfdad" title="TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize.">mcuxClMath_ExactDivideOdd</a> with flow protection. </p>

</div>
</div>
<a id="ga604b79f6ec8a9f0cc2ccae1e58510bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604b79f6ec8a9f0cc2ccae1e58510bcc">&#9670;&nbsp;</a></span>MCUXCLMATH_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenY&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga39240333bddf11bceeea47e029a30ba8" title="Exact division.">mcuxClMath_ExactDivide</a>. </p>

</div>
</div>
<a id="gad820a29fd45470c09c3ae3e604d4e6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad820a29fd45470c09c3ae3e604d4e6c0">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkcByteLenY&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="group__mcux_cl_math___functions.html#ga39240333bddf11bceeea47e029a30ba8" title="Exact division.">mcuxClMath_ExactDivide</a> with flow protection. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga352cef03d92210d17e6f7973f3e1b6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352cef03d92210d17e6f7973f3e1b6b9">&#9670;&nbsp;</a></span>mcuxClMath_InitLocalUptrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_InitLocalUptrt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i3_i2_i1_i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i7_i6_i5_i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>localPtrUptrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noOfIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t **&#160;</td>
          <td class="paramname"><em>oldPtrUptrt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the new UPTRT and returns the address of existing UPTRT. </p>
<p>This function copies up to 8 offsets of PKC operands from existing UPTRT to the new UPTRT, sets PKC to be with the new UPTRT, and returns the address of original UPTRT. </p><dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i3_i2_i1_i0</td><td>the first 4 indices of offsets to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i7_i6_i5_i4</td><td>the second 4 indices of offsets to be copied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localPtrUptrt</td><td>pointer to the new UPTRT to be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noOfIndices</td><td>number of offsets to be copied from existing UPTRT to new UPTRT. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oldPtrUptrt</td><td>pointer which receives the pointer to the old UPTRT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac216619c765747a5573b7f2837b6b47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac216619c765747a5573b7f2837b6b47a">&#9670;&nbsp;</a></span>mcuxClMath_LeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_LeadingZeros </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>nLeadingZeros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of leading zeros of operand in the given buffer (length = ps1 OPLEN). </p>
<dl class="section attention"><dt>Attention</dt><dd>The offset (UPTRT[iX]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The length (ps1 OPLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of operand buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nLeadingZeros</td><td>the number of leading zero bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaceede49c0bd63319311ebff84d5fb2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceede49c0bd63319311ebff84d5fb2aa">&#9670;&nbsp;</a></span>mcuxClMath_TrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_TrailingZeros </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>nTrailingZeros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of trailing zeros of operand in the given buffer (length = ps1 OPLEN). </p>
<dl class="section attention"><dt>Attention</dt><dd>The offset (UPTRT[iX]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The length (ps1 OPLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of operand buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nTrailingZeros</td><td>the number of trailing zero bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70edadc0775e547faf48429664aacf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70edadc0775e547faf48429664aacf06">&#9670;&nbsp;</a></span>mcuxClMath_ShiftModulus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ShiftModulus </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>iNShifted_iN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left shifts modulus until most significant bit of the buffer (length = ps1 OPLEN) is 1, and stores the result in the buffer specified. </p>
<dl class="section attention"><dt>Attention</dt><dd>The modulus must be non-zero. </dd>
<dd>
The offset (UPTRT[iN]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The length (ps1 OPLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iNShifted_iN</td><td>iNShifted: index of buffer in which the result will be stored. <br />
 iN: index of modulus buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe27ab61e1477e3adb92712ef0aaeee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe27ab61e1477e3adb92712ef0aaeee0">&#9670;&nbsp;</a></span>mcuxClMath_NDash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_NDash </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares modulus buffer (initializes NDash) to be used in modular multiplication (inversion, ...) with odd modulus. </p>
<p>This function calculates NDash = (-n)^(-1) mod 256^("PKC wordsize"), and stores the result in the PKC word in front of the modulus (n) buffer. </p><dl class="section attention"><dt>Attention</dt><dd>The modulus must be an odd number. </dd>
<dd>
The offset (UPTRT[iN]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iT</td><td>iN: index of modulus buffer. The result (NDash) will be stored in the PKC word in front of the modulus buffer. <br />
 iT: index of temp buffer, of which the size should be at least 2 PKC words. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c452a7ff7f0666825f923e7b96a5a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c452a7ff7f0666825f923e7b96a5a46">&#9670;&nbsp;</a></span>mcuxClMath_QDash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_QDash </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iQDash_iNShifted_iN_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates Q * Q' mod n, where Q = 256^(ps1 OPLEN) mod n, and Q' = 256^len mod n. </p>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (MCLEN = OPLEN = operandSize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. <br />
 The result might be greater than the modulus. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQDash_iNShifted_iN_iT</td><td>iQDash: index of QDash buffer, in which the result will be stored. <br />
 iNShifted: index of shifted modulus. If the bit length of modulus is equal to the operand size (i.e., most significant bit is 1), it can be the same as iN. <br />
 iN: index of modulus buffer. NDash of the modulus should be store in front of it. <br />
 iT: index of temp buffer, of which the size should be at least operandSize + PKC wordsize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>specify Q' = 256^len mod n. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga614b5ea66996bc85636ee1dd8d135491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614b5ea66996bc85636ee1dd8d135491">&#9670;&nbsp;</a></span>mcuxClMath_QSquared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_QSquared </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iQSqr_iNShifted_iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates Q^2 mod n, where Q = 256^(ps1 OPLEN) mod n. </p>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (MCLEN = OPLEN = operandSize). </dd>
<dd>
The length (ps1 OPLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. <br />
 The result might be greater than the modulus. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQSqr_iNShifted_iN_iT</td><td>iQSqr: index of QSqr buffer, in which the result will be stored. <br />
 iNShifted: index of shifted modulus. If the bit length of modulus is equal to the operand size (i.e., most significant bit is 1), it can be the same as iN. <br />
 iN: index of modulus buffer. NDash of the modulus should be store in front of it. <br />
 iT: index of temp buffer, of which the size should be at least operandSize + PKC wordsize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4cdfcc801cef8e8546a309e9f102273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4cdfcc801cef8e8546a309e9f102273">&#9670;&nbsp;</a></span>mcuxClMath_ModInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ModInv </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular inversion, X^(-1) mod n. </p>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (MCLEN = OPLEN = operandSize). </dd>
<dd>
The offsets (UPTRT[iR] and UPTRT[iT]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
if X and n are not coprime, the result will be incorrect, and the modulus n will be destroyed. </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. <br />
 The result fits in operandSize but might be greater than the modulus. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>iR: index of result buffer, of which the size should be at least operandSize + PKC wordsize. <br />
 iX: index of X buffer, of which the content (X) will be destroyed. <br />
 iN: index of modulus buffer. NDash of the modulus should be store in front of it. <br />
 iT: index of temp buffer, of which the size should be at least operandSize + PKC wordsize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08c5acc0cc1b9a7a9467b533669a881e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c5acc0cc1b9a7a9467b533669a881e">&#9670;&nbsp;</a></span>mcuxClMath_ReduceModEven()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ReduceModEven </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iT1_iT2_iT3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular reduction with even modulus, x mod n, where n is even. </p>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (MCLEN = lenX = length of x, OPLEN = lenN = length of n). </dd>
<dd>
The lengths (ps1 OPLEN and MCLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The offset (UPTRT[iN]) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT0</td><td>(bits 31~24) iR: index of result buffer, of which the size shall be at least (lenN + PKC wordsize). <br />
 (bits 23~16) iX: index of input buffer, of which the size shall be at least (lenX + PKC wordsize). <br />
 (bits 15~8) iN: index of modulus buffer, of which the size is lenN. <br />
 (bits 7~0) iT0: index of temp buffer, of which the size shall be at least (lenN + PKC wordsize). Buffer N can be used as T0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT1_iT2_iT3</td><td>(bits 23~16) iT1: index of temp buffer, of which the size shall be at least lenN. Buffer R can be used as T1. TODO: use R (any reason not using R?) <br />
 (bits 15~8) iT2: index of temp buffer, of which the size shall be at least lenN. <br />
 (bits 7~0) iT3: index of temp buffer, of which the size shall be at least (lenN + PKC wordsize). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga010598433e6c335c23e561795725718a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga010598433e6c335c23e561795725718a">&#9670;&nbsp;</a></span>mcuxClMath_ModExp_SqrMultL2R()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ModExp_SqrMultL2R </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteLenExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular exponentiation with left-to-right binary square and multiply algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent, which is stored as a big-endian octet string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteLenExp</td><td>byte length of exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>indices of operands in PKC workarea.</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and must be non-zero. </dd>
<dt><code>iR_iX_iN_iT</code>  </dt>
<dd>iR (bits 31~24): index of result. The size shall be at least (lenN + PKC wordsize). <br />
 iX (bits 23~16): index of base number. <br />
 iN (bits 15~8): index of modulus. NDash of the modulus should be stored in front of it. <br />
 iT (bits 7~0): index of temp operand. The size shall be at least (lenN + PKC wordsize).  </dd>
</dl>
</dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (OPLEN = MCLEN = lenX (= length of x) = lenN (= length of n)). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>

</div>
</div>
<a id="gaf0eecd504a144ccef7606bbf0a2dcc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0eecd504a144ccef7606bbf0a2dcc5d">&#9670;&nbsp;</a></span>mcuxClMath_SecModExp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_SecModExp </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pExpTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteLenExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iT3_iX_iT2_iT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iN_iTE_iT0_iR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Securely calculates modular exponentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent, which is stored as a big-endian octet string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExpTemp</td><td>pointer to temporary buffer, in either CPU or PKC workarea. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteLenExp</td><td>byte length of exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT3_iX_iT2_iT1</td><td>indices of operands in PKC workarea. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iTE_iT0_iR</td><td>indices of operands in PKC workarea.</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and must be non-zero. </dd>
<dt><code>pExpTemp</code>  </dt>
<dd>the temporary buffer shall be aligned to CPU word, and it's length shall be a multiple of CPU word and greater than <code>byteLenExp</code>.  </dd>
<dt><code>iT3_iX_iT2_iT1</code>  </dt>
<dd>iT3 (bits 31~24): index of temp3. The size shall be a multiple of PKC word and at least max(lenN, 2 * PKC wordsize). <br />
 iX (bits 23~16): index of base number. The size shall be a multiple of PKC word and at least lenN. <br />
 iT2 (bits 15~8): index of temp2. The size shall be a multiple of PKC word and at least max(lenN, 2 * PKC wordsize) <br />
 iT1 (bits 7~0): index of temp1. The size shall be a multiple of PKC word and at least max(lenN, <code>byteLenExp</code> + 1, 2 * PKC wordsize).  </dd>
<dt><code>iN_iTE_iT0_iR</code>  </dt>
<dd>iN (bits 31~24): index of modulus. NDash of the modulus should be stored in front of it. <br />
 iTE (bits 23~16): index of temp4. The size shall be a multiple of PKC word and at least (5 * PKC wordsize). <br />
 iT0 (bits 15~8): index of temp0. The size shall be a multiple of PKC word and at least max(<code>byteLenExp</code> + 1, lenN + PKC wordsize). <br />
 iR (bits 7~0): index of result. The size shall be a multiple of PKC word and at least max(<code>byteLenExp</code> + 1, lenN + PKC wordsize).  </dd>
</dl>
</dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both ps1 (OP)LEN and MCLEN need to be initialized (OPLEN = MCLEN = lenX (= length of x) = lenN (= length of n)). </dd>
<dd>
The lengths (ps1 OPLEN and MCLEN) must be initialized properly (equal to a multiple of PKC wordsize). </dd>
<dd>
The PKC calculation might be still on-going, call <a class="el" href="group__mcux_cl_pkc___functions___wait.html#ga40ddc839e15d88e6f079218af18fd3e6" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>

</div>
</div>
<a id="gaf2f74fa630792978ea7f58731b5bfdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2f74fa630792978ea7f58731b5bfdad">&#9670;&nbsp;</a></span>mcuxClMath_ExactDivideOdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ExactDivideOdd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iY_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pkcByteLenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pkcByteLenY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO 1.pkcByteLenX and pkcByteLenY shall be a multiple of pkc wordsize. </p>
<p>2.the most significant PKC word of Y shall be nonzero. 3.size of temp (iT) is 3 pkc wordsizes. 4.if lenX = lenY = pkc wordsize, this function will access to one extra pkc word on top of X. (i.e., read/write to X[pkc word 0], read X[pkc word 1]). </p>

</div>
</div>
<a id="ga39240333bddf11bceeea47e029a30ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39240333bddf11bceeea47e029a30ba8">&#9670;&nbsp;</a></span>mcuxClMath_ExactDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mcux_cl_math___macros.html#gafa468366650de62f727c686728ca685f">mcuxClMath_Status_Protected_t</a> mcuxClMath_ExactDivide </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iY_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pkcByteLenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pkcByteLenY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exact division. </p>
<p>This function computes the exact division r = x / y.</p>
<p>This function relies on mcuxClMath_ExactDivideOdd to compute the exact division of x / y. Suppose X is a multiple of Y, this function finds R such that (-X) + Y * R = 0. If there is a remainder to this division, this function will fail. The function destroys the content of buffer x. If this content is needed after the function call, it has to be backed up by the caller of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iR_iX_iY_iT</td><td>Pointer table indices of parameters </td></tr>
    <tr><td class="paramname">pkcByteLenX</td><td>Bytelength of parameter X </td></tr>
    <tr><td class="paramname">pkcByteLenY</td><td>Bytelength of parameter Y</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties  </dt>
<dd><dl>
<dt>iR_iX_iY_iT: </dt>
<dd>iR - index of result buffer r; the caller has to reserve a buffer of size bytelen(x) - bytelen(y) + 2 * MCUXCLPKC_WORDSIZE iX - index of input buffer x; the content of buffer x is modified during processing of mcuxClMath_ExactDivide; if it is still needed after the function call, the buffer should be backed up iY - index of input buffer y; the most significant PKC word of Y shall be nonzero iT - index of temporary buffer; the size of the temporary buffer is 3 * pkc wordsize </dd>
<dt>pkcByteLenX: </dt>
<dd>Must be a multiple of the pkc wordsize. If pkcByteLenX = pkcByteLenY = pkc wordsize, this function accesses one extra pkc word on top of X. </dd>
<dt>pkcByteLenY: </dt>
<dd>Must be a multiple of the pkc wordsize. </dd>
</dl>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">MCUXCLMATH_ERRORCODE_OK</td><td>Division successful </td></tr>
    <tr><td class="paramname">MCUXCLMATH_ERRORCODE_ERROR</td><td>Error occured during divide operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
